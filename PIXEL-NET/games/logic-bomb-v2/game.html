<!-- 
Theme: Cyberpunk / Retro Arcade / Hacking
Font: 'Courier New', Courier, monospace
Style: Neon grid, high contrast, softened scanlines, centered HUD
Colors: 
  - Background: Dynamic (Level-based)
  - Player: #00ff88 (Neon Green)
  - Enemies: #ff2a2a (Red)
  - Coin: Dynamic (Level-based)
  - Wall: Dynamic (Level-based)
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logic Bomb</title>
    <style>
        :root {
            --bg-color: #050510;
            --grid-color: #1a1a2e;
            --wall-color: #3b3b98;
            --player-color: #00ff88;
            --enemy-color: #ff2a2a;
            --coin-color: #00ccff;
            --lock-color: #ff00ff;
            --text-color: #ffffff;
            --ui-font: 'Courier New', Courier, monospace;
        }

        html, body {
            width: 100%;
            height: 100%;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--ui-font);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            overflow: hidden; 
            user-select: none;
            transition: background-color 0.5s;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px var(--player-color);
            border: 2px solid #333;
            background-color: #000;
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: auto;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            box-sizing: border-box;
            display: none; 
        }

        .hud-top {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 32px; 
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            padding: 0 2%;
            box-sizing: border-box;
            font-size: clamp(14px, 3.5vmin, 20px);
            font-weight: bold;
            text-shadow: 0 0 8px var(--player-color);
            align-items: center;
        }

        .hud-top > div {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
        }

        .battery-container {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .battery {
            width: 22px;
            height: 10px;
            border: 2px solid #00ff88;
            position: relative;
            box-shadow: 0 0 8px #00ff88;
        }
        .battery::after {
            content: '';
            position: absolute;
            right: -4px;
            top: 1px;
            width: 2px;
            height: 4px;
            background: #00ff88;
        }
        .battery-fill {
            width: 100%;
            height: 100%;
            background: #00ff88;
        }

        .hud-bottom {
            position: absolute;
            left: 0;
            bottom: 0;
            width: 100%;
            padding: 0 2% 8px;
            box-sizing: border-box;
            text-align: center;
            font-size: clamp(10px, 2.5vmin, 14px);
            color: #aaa;
            margin-bottom: 5px;
        }

        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.95);
            border: 2px solid var(--player-color);
            padding: 5%;
            text-align: center;
            display: none;
            z-index: 100;
            width: 80%;
            max-width: 400px;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
        }

        #message-title {
            font-size: clamp(24px, 6vmin, 48px);
            margin-bottom: 10px;
            color: var(--player-color);
            text-shadow: 0 0 20px var(--player-color);
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 900;
        }

        button {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--player-color);
            color: var(--player-color);
            padding: 10px 20px;
            font-family: var(--ui-font);
            font-size: clamp(16px, 4vmin, 24px);
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: auto;
        }

        button:hover {
            background: var(--player-color);
            color: #000;
            box-shadow: 0 0 30px var(--player-color);
            transform: scale(1.05);
        }

        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 70%,
                rgba(0,0,0,0.05) 70%,
                rgba(0,0,0,0.05)
            );
            background-size: 100% 6px;
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas" width="640" height="640"></canvas>
        <div class="scanlines"></div>

        <div id="ui-layer">
            <div class="hud-top">
                <div id="score-display">DATA: 0</div>
                <div id="level-display">LVL: 1</div>
                <div class="battery-container" id="lives-display"></div>
            </div>
            <div class="hud-bottom" id="hud-controls">
                WASD/ARROWS: Move | SPACE: Bomb/Start | ENTER: Start
            </div>
        </div>

        <div id="level-indicator" style="position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%); font-size: 40px; color: var(--player-color); font-weight: bold; display: none; text-shadow: 0 0 15px var(--player-color);">LEVEL 1</div>

        <div id="message-box" class="ui-start">
            <div id="message-title">LOGIC BOMB</div>
            <div id="message-subtitle" style="margin-bottom: 20px;">Plant the payload. Crash the system.</div>
            <button id="start-btn">EXECUTE</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const levelDisplay = document.getElementById('level-display');
        const livesDisplay = document.getElementById('lives-display');
        const uiLayer = document.getElementById('ui-layer');
        const hudControls = document.getElementById('hud-controls');
        const messageBox = document.getElementById('message-box');
        const startBtn = document.getElementById('start-btn');
        const levelIndicator = document.getElementById('level-indicator');

        // --- CONSTANTS ---
        const TILE_SIZE = 32, COLS = 20, ROWS = 20, PLAYER_SPEED = 3;
        const LOCK_DURATION = 90, TUNNEL_ROW = 9, MAX_BOMBS = 1, BOMB_COOLDOWN_TIME = 80;
        const WALL = 1, PATH = 0, COIN = 2, LOCK = 3;
        const DIR = { UP: { x: 0, y: -1 }, DOWN: { x: 0, y: 1 }, LEFT: { x: -1, y: 0 }, RIGHT: { x: 1, y: 0 }, NONE: { x: 0, y: 0 } };

        const COLOR_SCHEMES = [
            { bg: '#050510', wallFill: '#1a1a40', wallBorder: '#3b3b98', coin: '#00ccff' },
            { bg: '#000f00', wallFill: '#002000', wallBorder: '#00ff00', coin: '#ccffcc' },
            { bg: '#100500', wallFill: '#301000', wallBorder: '#ff4400', coin: '#ffaa00' },
            { bg: '#100010', wallFill: '#200020', wallBorder: '#ff00ff', coin: '#ffff00' }
        ];

        const MAP_1 = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,2,2,2,2,2,1,2,2,2,2,2,2,1,2,2,2,2,2,1],[1,2,1,1,1,2,1,2,1,1,1,1,2,1,2,1,1,1,2,1],[1,2,1,0,1,2,2,2,2,2,2,2,2,2,2,1,0,1,2,1],[1,2,1,2,1,2,1,1,1,0,0,1,1,1,2,1,2,1,2,1],[1,2,2,2,2,2,1,0,0,0,0,0,0,1,2,2,2,2,2,1],[1,2,1,1,1,2,1,0,1,1,1,1,0,1,2,1,1,1,2,1],[1,2,2,2,2,2,0,0,1,0,0,1,0,0,2,2,2,2,2,1],[1,1,1,1,1,2,1,1,1,0,0,1,1,1,2,1,1,1,1,1],[0,0,0,0,0,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0],[1,1,1,1,1,2,1,1,1,0,0,1,1,1,2,1,1,1,1,1],[1,2,2,2,2,2,0,0,1,0,0,1,0,0,2,2,2,2,2,1],[1,2,1,1,1,2,1,0,1,1,1,1,0,1,2,1,1,1,2,1],[1,2,2,2,1,2,1,0,0,0,0,0,0,1,2,1,2,2,2,1],[1,1,1,2,1,2,1,1,1,0,0,1,1,1,2,1,2,1,1,1],[1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],[1,2,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,2,1],[1,2,2,2,1,2,2,2,2,1,1,2,2,2,2,1,2,2,2,1],[1,2,1,2,2,2,1,1,2,2,2,2,1,2,2,2,1,2,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
        const MAP_2 = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1],[1,2,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,2,1],[1,2,1,0,1,2,2,2,2,2,2,2,2,2,2,1,0,1,2,1],[1,2,2,2,2,2,1,1,1,0,0,1,1,1,2,2,2,2,2,1],[1,1,2,1,1,2,1,0,0,0,0,0,0,1,2,1,1,2,1,1],[1,2,2,2,2,2,1,0,1,1,1,1,0,1,2,2,2,2,2,1],[1,2,1,1,1,2,0,0,1,0,0,1,0,0,2,1,1,1,2,1],[1,2,2,2,2,2,1,1,1,0,0,1,1,1,2,2,2,2,2,1],[0,0,0,0,0,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0],[1,2,2,2,2,2,1,1,1,0,0,1,1,1,2,2,2,2,2,1],[1,2,1,1,1,2,0,0,1,0,0,1,0,0,2,1,1,1,2,1],[1,2,2,2,2,2,1,0,1,1,1,1,0,1,2,2,2,2,2,1],[1,1,2,1,1,2,1,0,0,0,0,0,0,1,2,1,1,2,1,1],[1,2,2,2,2,2,1,1,1,0,0,1,1,1,2,2,2,2,2,1],[1,2,1,0,1,2,2,2,2,2,2,2,2,2,2,1,0,1,2,1],[1,2,1,1,1,2,1,1,2,1,1,2,1,1,2,1,1,1,2,1],[1,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
        const MAP_3 = [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], [1,2,2,2,2,1,2,2,2,1,1,2,2,2,1,2,2,2,2,1], [1,2,1,1,2,1,2,1,2,1,1,2,1,2,1,2,1,1,2,1], [1,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,1], [1,2,1,1,1,1,2,1,1,0,0,1,1,2,1,1,1,1,2,1], [1,2,1,0,0,0,2,0,0,0,0,0,0,2,0,0,0,1,2,1], [1,2,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,2,1], [1,2,2,2,2,2,2,0,0,1,1,0,0,2,2,2,2,2,2,1], [1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1], [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], [1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1], [1,2,2,2,2,2,2,0,0,1,1,0,0,2,2,2,2,2,2,1], [1,2,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,2,1], [1,2,1,0,0,0,2,0,0,0,0,0,0,2,0,0,0,1,2,1], [1,2,1,1,1,1,2,1,1,0,0,1,1,2,1,1,1,1,2,1], [1,2,2,2,2,2,2,1,2,2,2,2,1,2,2,2,2,2,2,1], [1,2,1,1,2,1,2,1,2,1,1,2,1,2,1,2,1,1,2,1], [1,2,2,2,2,1,2,2,2,1,1,2,2,2,1,2,2,2,2,1], [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]];
        const LEVELS = [{ map: MAP_1 }, { map: MAP_2 }, { map: MAP_3 }];

        // --- AUDIO ---
        let audioCtx = null;
        let sizzleNode = null;
        function ensureAudio() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }
        function playSfx(f1, f2, type, vol, dur) {
            ensureAudio();
            const t = audioCtx.currentTime;
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.type = type; o.frequency.setValueAtTime(f1, t);
            o.frequency.exponentialRampToValueAtTime(f2, t + dur);
            g.gain.setValueAtTime(vol, t); g.gain.exponentialRampToValueAtTime(0.001, t + dur);
            o.connect(g); g.connect(audioCtx.destination);
            o.start(); o.stop(t + dur);
        }
        function playKaboom() {
            ensureAudio();
            const t = audioCtx.currentTime;
            const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.8, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
            const n = audioCtx.createBufferSource(); n.buffer = buffer;
            const f = audioCtx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.setValueAtTime(400, t);
            const g = audioCtx.createGain(); g.gain.setValueAtTime(0.5, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.7);
            n.connect(f); f.connect(g); g.connect(audioCtx.destination);
            n.start();
        }

        function startSizzle() {
            ensureAudio(); if (sizzleNode) return;
            const t = audioCtx.currentTime;
            const bufferSize = audioCtx.sampleRate * 2;
            const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const source = audioCtx.createBufferSource();
            source.buffer = noiseBuffer; source.loop = true;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'highpass'; filter.frequency.setValueAtTime(2500, t);
            const g = audioCtx.createGain();
            g.gain.setValueAtTime(0.0001, t); g.gain.exponentialRampToValueAtTime(0.02, t + 0.2);
            const lfo = audioCtx.createOscillator();
            lfo.type = 'square'; lfo.frequency.setValueAtTime(15, t);
            const lfoG = audioCtx.createGain(); lfoG.gain.setValueAtTime(0.01, t);
            lfo.connect(lfoG); lfoG.connect(g.gain);
            source.connect(filter); filter.connect(g); g.connect(audioCtx.destination);
            source.start(t); lfo.start(t);
            sizzleNode = { src: source, gain: g, lfo: lfo };
        }
        function stopSizzle() {
            if (!audioCtx || !sizzleNode) return;
            const t = audioCtx.currentTime;
            sizzleNode.gain.gain.cancelScheduledValues(t);
            sizzleNode.gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.05);
            sizzleNode.src.stop(t + 0.1); sizzleNode.lfo.stop(t + 0.1); sizzleNode = null;
        }

        // --- GAME STATE ---
        let gameRunning = false, score = 0, lives = 3, currentLevel = 0, frameCount = 0, bombCooldownTimer = 0;
        let __pixelnetScorePosted = false;
        let map = [], activeLocks = [], explosions = [], floatingTexts = [], shakeIntensity = 0;
        let player = { x: 0, y: 0, dir: DIR.NONE, nextDir: DIR.NONE, color: '#00ff88', radius: 11 };
        let enemies = [];
        let spacePressed = false;
        let currentPalette = COLOR_SCHEMES[0];

        // --- INPUT ---
        window.addEventListener('keydown', (e) => {
            const code = e.code;
            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "KeyW", "KeyA", "KeyS", "KeyD", "Space", "KeyN", "Enter"].indexOf(code) > -1) e.preventDefault();
            
            // FIXED: Start menu keyboard interaction
            if (!gameRunning && messageBox.style.display === 'block') {
                if (code === 'Space' || code === 'Enter') {
                    executeAction();
                    return;
                }
            }

            if (gameRunning) {
                if (code === 'ArrowUp' || code === 'KeyW') player.nextDir = DIR.UP;
                if (code === 'ArrowDown' || code === 'KeyS') player.nextDir = DIR.DOWN;
                if (code === 'ArrowLeft' || code === 'KeyA') player.nextDir = DIR.LEFT;
                if (code === 'ArrowRight' || code === 'KeyD') player.nextDir = DIR.RIGHT;
                if (code === 'Space' && !spacePressed) { handleBombInput(); spacePressed = true; }
                if (code === 'KeyN') { currentLevel++; resetLevel(); playSfx(400, 800, 'sine', 0.05, 0.2); }
            }
        });
        window.addEventListener('keyup', (e) => { if (e.code === 'Space') spacePressed = false; });

        // Unified Execute function
        function executeAction() {
            ensureAudio();
            __pixelnetScorePosted = false;
            messageBox.style.display = 'none'; 
            uiLayer.style.display = 'block'; 
            initGame(); 
            gameRunning = true; 
            loop(); 
        }

        startBtn.addEventListener('click', executeAction);

        function initGame() { score = 0; lives = 3; currentLevel = 0; resetLevel(); }

        function applyColorsToUI() {
            const root = document.documentElement;
            root.style.setProperty('--bg-color', currentPalette.bg);
            root.style.setProperty('--wall-color', currentPalette.wallBorder);
            root.style.setProperty('--coin-color', currentPalette.coin);
        }

        function resetLevel() {
            const mapIndex = currentLevel % LEVELS.length;
            const schemeIndex = currentLevel % COLOR_SCHEMES.length;
            currentPalette = COLOR_SCHEMES[schemeIndex];
            applyColorsToUI();
            map = JSON.parse(JSON.stringify(LEVELS[mapIndex].map));
            activeLocks = []; explosions = []; floatingTexts = []; bombCooldownTimer = 0;
            player.x = 10 * TILE_SIZE + 16; player.y = 15 * TILE_SIZE + 16;
            player.dir = DIR.NONE; player.nextDir = DIR.NONE;
            createEnemies(Math.min(10, 5 + currentLevel), 2.3 + (currentLevel * 0.1));
            updateHUD();
            levelIndicator.innerText = `LEVEL ${currentLevel + 1}`;
            levelIndicator.style.display = 'block';
            setTimeout(() => levelIndicator.style.display = 'none', 1500);
        }

        function createEnemies(count, speed) {
            enemies = [];
            const pts = [{ c: 1, r: 1 }, { c: 18, r: 1 }, { c: 1, r: 18 }, { c: 18, r: 18 }, { c: 9, r: 8 }];
            for (let i = 0; i < count; i++) {
                const pt = pts[i % pts.length];
                enemies.push({
                    x: pt.c * 32 + 16, y: pt.r * 32 + 16, color: '#ff2a2a', dir: DIR.NONE, nextDir: DIR.NONE, speed,
                    startX: pt.c * 32 + 16, startY: pt.r * 32 + 16, deadTimer: 0, lastX: 0, lastY: 0, stuckFrames: 0, lastDeathCorner: -1
                });
            }
        }

        function handleBombInput() {
            const col = Math.floor(player.x / TILE_SIZE), row = Math.floor(player.y / TILE_SIZE);
            if (map[row] && map[row][col] !== WALL && !activeLocks.some(l => l.x === col && l.y === row) && activeLocks.length < MAX_BOMBS && bombCooldownTimer === 0) {
                activeLocks.push({ x: col, y: row, timer: LOCK_DURATION });
                playSfx(200, 60, 'triangle', 0.1, 0.15); startSizzle();
            } else if (activeLocks.length > 0) detonateAll();
        }

        function detonateAll() {
            while (activeLocks.length > 0) { const lock = activeLocks.pop(); createExplosion(lock.x, lock.y); bombCooldownTimer = BOMB_COOLDOWN_TIME; }
            stopSizzle();
        }

        function getTileAt(x, y) {
            const col = Math.floor(x / TILE_SIZE), row = Math.floor(y / TILE_SIZE);
            if (row === TUNNEL_ROW && (col < 0 || col >= COLS)) return PATH;
            if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return WALL;
            if (activeLocks.find(l => l.x === col && l.y === row)) return LOCK;
            return map[row][col];
        }

        function canMove(x, y, dir, isP = false) {
            const nx = x + dir.x * 17, ny = y + dir.y * 17;
            const tile = getTileAt(nx, ny);
            if (tile === WALL) return false;
            return tile === LOCK ? isP : true;
        }

        function moveEntity(e, isP = false) {
            if (e.deadTimer > 0) return;
            if (!isP) { 
                if (Math.abs(e.x - e.lastX) < 0.1 && Math.abs(e.y - e.lastY) < 0.1) e.stuckFrames++; 
                else e.stuckFrames = 0; 
                e.lastX = e.x; e.lastY = e.y; 
            }
            
            const cx = Math.floor(e.x / TILE_SIZE) * 32 + 16, cy = Math.floor(e.y / TILE_SIZE) * 32 + 16;
            
            // --- ENHANCED RESPONSIVE MOVEMENT ---
            // If the user has a buffered turn intent (nextDir)
            if (e.nextDir && e.nextDir !== DIR.NONE && e.nextDir !== e.dir) {
                const distToCenter = Math.sqrt((e.x - cx)**2 + (e.y - cy)**2);
                // Increased hook range to 14px to ensure corners are never missed at any frame rate
                if (distToCenter < 14) { 
                    if (canMove(cx, cy, e.nextDir, isP)) {
                        e.x = cx; e.y = cy; e.dir = e.nextDir;
                        if (!isP) e.nextDir = DIR.NONE;
                    }
                }
            }

            if (e.dir !== DIR.NONE) {
                if (canMove(e.x, e.y, e.dir, isP)) {
                    e.x += e.dir.x * (isP ? PLAYER_SPEED : e.speed); 
                    e.y += e.dir.y * (isP ? PLAYER_SPEED : e.speed);
                    if (e.x < -16) e.x = 656; else if (e.x > 656) e.x = -16;
                } else { 
                    // Snap to tile center on collision for precision
                    e.x = cx; e.y = cy; e.dir = DIR.NONE; 
                }
            }
        }

        function updateAI(e) {
            if (e.deadTimer > 0) return;
            const cx = Math.floor(e.x / 32) * 32 + 16, cy = Math.floor(e.y / 32) * 32 + 16;
            if (Math.sqrt((e.x - cx) ** 2 + (e.y - cy) ** 2) < 2 || e.stuckFrames > 10) {
                const opts = [DIR.UP, DIR.DOWN, DIR.LEFT, DIR.RIGHT].filter(d => !(d.x === -e.dir.x && d.y === -e.dir.y && e.dir !== DIR.NONE) && canMove(cx, cy, d, false));
                if (opts.length === 0) opts.push({ x: -e.dir.x, y: -e.dir.y });
                if (e.stuckFrames > 10 || Math.random() < 0.2) e.nextDir = opts[Math.floor(Math.random() * opts.length)];
                else {
                    let best = opts[0], min = Infinity;
                    opts.forEach(o => { const d = (cx + o.x * 32 - player.x) ** 2 + (cy + o.y * 32 - player.y) ** 2; if (d < min) { min = d; best = o; } });
                    e.nextDir = best;
                }
                if (e.stuckFrames > 10) e.stuckFrames = 0;
            }
        }

        function checkCollisions() {
            const c = Math.floor(player.x / 32), r = Math.floor(player.y / 32);
            if (map[r] && map[r][c] === COIN) {
                map[r][c] = PATH; score += 10; updateHUD(); playSfx(900, 1400, 'sine', 0.05, 0.1);
                if (!map.some(row => row.includes(COIN))) { currentLevel++; resetLevel(); }
            }
            enemies.forEach(e => { if (e.deadTimer <= 0 && Math.sqrt((player.x - e.x) ** 2 + (player.y - e.y) ** 2) < 24) handleDeath(); });
        }

        function createExplosion(gx, gy) {
            playKaboom();
            const cx = gx * TILE_SIZE + 16, cy = gy * TILE_SIZE + 16;
            shakeIntensity = 15; explosions.push({ type: 'shockwave', x: cx, y: cy, radius: 10, alpha: 1, lethal: true });
            for (let i = 0; i < 30; i++) {
                const a = Math.random() * 6.28, s = Math.random() * 5 + 2;
                explosions.push({ type: 'particle', x: cx, y: cy, vx: Math.cos(a) * s, vy: Math.sin(a) * s, life: 1 });
            }
        }

        function checkExplosionDamage(s) {
            if (Math.sqrt((player.x - s.x) ** 2 + (player.y - s.y) ** 2) < s.radius) { handleDeath(); return; }
            enemies.forEach(e => {
                if (e.deadTimer <= 0 && Math.sqrt((e.x - s.x) ** 2 + (e.y - s.y) ** 2) < s.radius + 10) {
                    e.deadTimer = 180; e.x = -1000; score += 100; updateHUD();
                    floatingTexts.push({ x: s.x, y: s.y, text: "+100", life: 1, dy: -1 });
                }
            });
        }

        function handleDeath() {
            stopSizzle(); 
            lives--; updateHUD(); ctx.fillStyle = 'white'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (lives <= 0) { 
                gameRunning = false;
                // PIXEL-NET: submit score once to wrapper leaderboard
                if (!__pixelnetScorePosted) {
                    __pixelnetScorePosted = true;
                    try { window.parent.postMessage({ type: 'GAME_OVER_SCORE', score: Number(score) || 0 }, '*'); } catch (_) {}
                } 
                messageBox.style.display = 'block'; 
                uiLayer.style.display = 'none'; 
                const msgTitle = document.getElementById('message-title');
                const msgSub = document.querySelector('#message-box #message-subtitle');
                msgTitle.innerText = "SYSTEM FAILURE";
                msgSub.innerText = "Breach terminated. Final score: " + score;
            }
            else resetLevel();
        }

        function updateHUD() {
            scoreDisplay.textContent = `DATA: ${score}`;
            levelDisplay.textContent = `LVL: ${currentLevel + 1}`;
            livesDisplay.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                const b = document.createElement('div'); b.className = 'battery';
                if (i < lives) { const f = document.createElement('div'); f.className = 'battery-fill'; b.appendChild(f); }
                livesDisplay.appendChild(b);
            }
            if (hudControls) {
                hudControls.innerHTML = bombCooldownTimer > 0 ? `<span style="color:#ff2a2a">RECHARGING...</span>` : (activeLocks.length > 0 ? `<span style="color:#ff00ff">DETONATE (SPACE)</span>` : `<span style="color:#00ff88">BOMB READY (SPACE)</span>`);
            }
        }

        function drawIdentity(x, y) {
            ctx.save(); ctx.translate(x, y); ctx.strokeStyle = player.color; ctx.fillStyle = player.color; ctx.lineWidth = 1.8; ctx.shadowBlur = 10; ctx.shadowColor = player.color;
            ctx.beginPath(); ctx.arc(0, 0, player.radius, 0, 6.28); ctx.fill();
            ctx.fillStyle = '#000'; ctx.beginPath(); 
            ctx.arc(player.dir.x * 6, player.dir.y * 6, 3, 0, 6.28); ctx.fill();
            ctx.restore();
        }

        function drawBomb(gx, gy, timer) {
            const cx = gx * TILE_SIZE + 16, cy = gy * TILE_SIZE + 16 + 2, p = timer / LOCK_DURATION;
            const grad = ctx.createRadialGradient(cx-3, cy-3, 2, cx, cy, 10);
            grad.addColorStop(0, '#777'); grad.addColorStop(1, '#111');
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(cx, cy, 10, 0, 6.28); ctx.fill();
            if (p > 0) {
                ctx.save(); ctx.translate(cx, cy-8); ctx.strokeStyle='#8b4513'; ctx.lineWidth=2.5; ctx.beginPath(); ctx.moveTo(0,0);
                const ex = Math.cos(frameCount*0.1)*3+12*p, ey = -18*p;
                ctx.quadraticCurveTo(10*p, -15, ex, ey); ctx.stroke();
                ctx.fillStyle='#ffcc00'; ctx.shadowBlur=12; ctx.shadowColor='#ffaa00'; ctx.beginPath(); ctx.arc(ex,ey,4,0,6.28); ctx.fill(); ctx.restore();
            }
            if (timer < 60 && Math.floor(frameCount / 5) % 2 === 0) { ctx.fillStyle = 'rgba(255,50,50,0.5)'; ctx.beginPath(); ctx.arc(cx, cy, 10, 0, 6.3); ctx.fill(); }
        }

        function draw() {
            ctx.fillStyle = currentPalette.bg; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save(); if (shakeIntensity > 0) ctx.translate((Math.random() - 0.5) * shakeIntensity, (Math.random() - 0.5) * shakeIntensity);
            for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
                const x = c * 32, y = r * 32, t = map[r][c];
                if (t === WALL) { 
                    ctx.fillStyle = currentPalette.wallFill; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); 
                    ctx.strokeStyle = currentPalette.wallBorder; ctx.lineWidth = 2; ctx.strokeRect(x + 4, y + 4, 24, 24); 
                }
                else if (t === COIN) { ctx.fillStyle = currentPalette.coin; ctx.beginPath(); ctx.arc(x + 16, y + 16, 3, 0, 6.3); ctx.fill(); }
            }
            activeLocks.forEach(l => drawBomb(l.x, l.y, l.timer));
            drawIdentity(player.x, player.y);
            enemies.forEach(e => {
                if (e.deadTimer > 0) return;
                ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(frameCount * 0.15); ctx.fillStyle = e.color; ctx.shadowBlur = 10; ctx.shadowColor = e.color;
                ctx.beginPath(); for(let i=0; i<4; i++){ ctx.rotate(1.57); ctx.moveTo(0,0); ctx.lineTo(4,-5); ctx.lineTo(0,-14); ctx.lineTo(-4,-5); } ctx.fill();
                ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(0,0,6,0,6.3); ctx.fill(); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,0,3+Math.sin(frameCount*0.2),0,6.3); ctx.fill();
                ctx.restore();
            });
            for (let i = explosions.length - 1; i >= 0; i--) {
                const ex = explosions[i]; if (!ex) continue;
                if (ex.type === 'shockwave') {
                    ctx.strokeStyle = `rgba(255,100,50,${ex.alpha})`; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.arc(ex.x, ex.y, ex.radius, 0, 6.3); ctx.stroke();
                } else {
                    ctx.globalAlpha = ex.life; ctx.fillStyle = '#ffaa00';
                    ctx.beginPath(); ctx.arc(ex.x, ex.y, 4, 0, 6.3); ctx.fill(); ctx.globalAlpha = 1;
                }
            }
            ctx.font = "bold 16px Courier New"; ctx.textAlign = "center";
            floatingTexts.forEach(ft => {
                ctx.fillStyle = `rgba(255, 255, 255, ${ft.life})`;
                ctx.fillText(ft.text, ft.x, ft.y);
            });
            ctx.restore();
        }

        function update() {
            if (!gameRunning) return;
            if (shakeIntensity > 0) shakeIntensity *= 0.9;
            if (bombCooldownTimer > 0) bombCooldownTimer--;
            moveEntity(player, true);
            enemies.forEach(e => { if (e.deadTimer > 0) { e.deadTimer--; if (e.deadTimer === 0) { e.x = e.startX; e.y = e.startY; e.dir = DIR.NONE; } } else { updateAI(e); moveEntity(e, false); } });
            checkCollisions();
            for (let i = activeLocks.length - 1; i >= 0; i--) {
                activeLocks[i].timer--;
                if (activeLocks[i].timer <= 0) { createExplosion(activeLocks[i].x, activeLocks[i].y); activeLocks.splice(i, 1); stopSizzle(); }
            }
            for (let i = explosions.length - 1; i >= 0; i--) {
                const ex = explosions[i]; if (!ex) continue;
                if (ex.type === 'shockwave') {
                    ex.radius += 5; ex.alpha -= 0.05;
                    if (ex.alpha > 0.4) checkExplosionDamage(ex);
                    if (ex.alpha <= 0) explosions.splice(i, 1);
                } else {
                    ex.x += ex.vx || 0; ex.y += ex.vy || 0; ex.life -= 0.03;
                    if (ex.life <= 0) explosions.splice(i, 1);
                }
            }
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                floatingTexts[i].y += floatingTexts[i].dy;
                floatingTexts[i].life -= 0.02;
                if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
            }
            frameCount++;
        }

        function loop() { if (gameRunning) { update(); draw(); requestAnimationFrame(loop); } }
        messageBox.style.display = 'block';
    </script>
</body>
</html>