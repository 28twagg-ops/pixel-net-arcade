<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ROBO-ARENA</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --text:#e9ecff;
      --muted:#a7b0d6;
      --stroke: rgba(255,255,255,.10);
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --panel: rgba(15,19,36,.72);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(255,0,122,.14), transparent 60%),
        radial-gradient(900px 500px at 85% 20%, rgba(0,255,247,.12), transparent 55%),
        linear-gradient(180deg, #050611 0%, #060716 100%);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      /* Allow scrolling outside the game area on mobile */
      overflow:auto;
      touch-action:pan-y;
    }
    .topbar{
      width:min(1200px, 92vw);
      margin:14px auto 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .btn{
      font-family:"Orbitron", system-ui, sans-serif;
      letter-spacing:.10em;
      text-transform:uppercase;
      border:1px solid rgba(0,255,247,.40);
      background: rgba(0,255,247,.10);
      color:#00f3ff;
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
    }
    .btn:hover{ background: rgba(0,255,247,.16); box-shadow:0 0 14px rgba(0,243,255,.20); }

    .badge{
      font-family:"Orbitron", system-ui, sans-serif;
      letter-spacing:.12em;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.28);
      padding:10px 12px;
      border-radius:18px;
      cursor:pointer;
      color:var(--text);
    }

    .layout{
      width:min(1200px, 92vw);
      margin:0 auto 16px;
      display:grid;
      grid-template-columns: 320px 1fr 320px;
      gap:14px;
      height: calc(100vh - 86px);
      min-height: 520px;
    }
    .panel{
      border:1px solid var(--stroke);
      background: var(--panel);
      border-radius:18px;
      box-shadow: var(--shadow);
      padding:14px;
      overflow:hidden;
    }
    .title{
      margin:0 0 10px 0;
      font-family:"Orbitron", system-ui, sans-serif;
      letter-spacing:.10em;
      font-size:13px;
      color: rgba(233,236,255,.92);
    }
    .muted{ color:var(--muted); font-size:13px; line-height:1.35; }
    .lb-meta{ margin-top:10px; font-size:12px; color:var(--muted); opacity:.9; }

    .gamewrap{ display:flex; flex-direction:column; gap:10px; }
    .gamebox{
      position:relative;
      flex:1;
      min-height: 420px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.35);
      overflow:hidden;
      touch-action:none; /* capture touch for joysticks */
    }

    /* Robo Arena internal styles (scoped) */
    #game-container{
      position:absolute;
      inset:0;
      display:flex;
      justify-content:center;
      align-items:center;
      background: radial-gradient(circle, #1a1a1a 0%, #000 100%);
    }
    canvas{
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.15);
      border: 4px solid #222;
      background-color: #000;
      max-width:100%;
      max-height:100%;
    }
    #ui-layer{
      position:absolute;
      top:0; left:0;
      width:100%; height:100%;
      pointer-events:none;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
    }
    .hud-top{
      display:flex;
      justify-content:space-between;
      padding:10px 20px;
      font-size:20px;
      text-shadow:0 0 5px currentColor;
      background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
      font-family: 'Courier New', Courier, monospace;
    }
    .hud-score{ color:#0ff; }
    .hud-lives{ color:#f0f; }
    .hud-level{ color:#ff0; }

    #start-screen, #game-over-screen{
      position:absolute;
      inset:0;
      background: rgba(0,0,0,0.9);
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      pointer-events:auto;
      z-index:10;
      padding: 18px;
    }
    #game-over-screen.hidden{ display:none !important; }
    h1{
      font-size: 3rem;
      margin: 0 0 6px 0;
      color:#f00;
      text-transform:uppercase;
      text-shadow:4px 4px 0px #fff;
      letter-spacing:5px;
      text-align:center;
      font-family: 'Courier New', Courier, monospace;
    }
    p{
      font-size:1rem;
      margin: 0 0 16px 0;
      color:#ddd;
      text-align:center;
      line-height:1.4;
      max-width:600px;
      font-family: 'Courier New', Courier, monospace;
    }
    .btn2{
      background: transparent;
      color:#0f0;
      border:2px solid #0f0;
      padding:10px 30px;
      font-size:1.2rem;
      font-family: 'Courier New', Courier, monospace;
      cursor:pointer;
      text-transform:uppercase;
      transition: all 0.2s;
      box-shadow: 0 0 10px #0f0;
      margin-top: 12px;
    }
    .btn2:hover{ background:#0f0; color:#000; box-shadow:0 0 20px #0f0; }

    .controls-info{
      display:flex;
      gap:40px;
      margin-bottom:18px;
      font-size:0.8rem;
      color:#aaa;
      font-family: 'Courier New', Courier, monospace;
    }
    .key-group{text-align:center}
    .key{display:inline-block;border:1px solid #666;padding:2px 6px;border-radius:4px;color:#fff;background:#222}

    .leaderboard{
      margin-top: 8px;
      border:2px solid #444;
      padding: 15px;
      background: rgba(20,20,20,0.8);
      width: 300px;
      box-shadow: 0 0 15px rgba(0,255,255,0.1);
    }
    .leaderboard h3{
      color:#ff0;
      margin:0 0 10px 0;
      text-align:center;
      text-transform:uppercase;
      letter-spacing:2px;
      border-bottom:1px solid #444;
      padding-bottom:5px;
      font-family: 'Courier New', Courier, monospace;
    }
    .score-row{ display:flex; justify-content:space-between; margin:5px 0; font-family: monospace; font-size:1.1rem; }
    .score-rank{ color:#888; margin-right:10px; }
    .score-name{ color:#0ff; }
    .score-val{ color:#fff; }

    #mobile-controls{
      display:none;
      position:absolute;
      bottom: 14px;
      left:0;
      width:100%;
      height:150px;
      pointer-events:none;
      justify-content:space-between;
      padding:0 26px;
      box-sizing:border-box;
      z-index: 20;
    }
    .joystick-zone{
      width:120px; height:120px;
      background: rgba(255,255,255,0.10);
      border-radius:50%;
      border:2px solid rgba(255,255,255,0.30);
      position:relative;
      pointer-events:auto;
    }
    .joystick-knob{
      width:50px;height:50px;
      background: rgba(255,255,255,0.50);
      border-radius:50%;
      position:absolute;
      top:50%; left:50%;
      transform: translate(-50%, -50%);
      pointer-events:none;
    }

    @media (max-width: 1100px){
      .layout{ grid-template-columns: 1fr; height:auto; min-height:0; }
      body{ overflow:auto; }
      .gamebox{ min-height: 62vh; }
    }
    @media (max-width: 768px){
      h1{ font-size:2rem; }
      .controls-info{ display:none; }
      #mobile-controls{ display:flex; }
      .leaderboard{ width: 90%; font-size:0.9rem; }
    }
  </style>

<!-- PIXEL-NET EMBED MODE (wrapper uses this) -->
<script>
(function(){
  try {
    var embed = (window.self !== window.top) || /[?&]embed=1\b/.test(location.search);
    if (embed) document.documentElement.classList.add("pn-embed");
  } catch(e) {
    document.documentElement.classList.add("pn-embed");
  }
})();
</script>
<style>
/* When embedded inside the canonical wrapper, show ONLY the game surface */
.pn-embed, .pn-embed body {
  margin: 0 !important;
  padding: 0 !important;
  height: 100% !important;
  overflow: hidden !important;
  background: transparent !important;
}
.pn-embed body > * { display: none !important; }
.pn-embed body {}
/* Keep the game surface visible */
.pn-embed #game-container, 
.pn-embed #game-container * {
  display: revert !important;
}
.pn-embed #game-container {
  position: fixed !important;
  inset: 0 !important;
  margin: 0 !important;
  width: 100vw !important;
  height: 100vh !important;
  overflow: hidden !important;
}
/* Canvas fills; preserves internal scaling */
.pn-embed canvas {
  display: block !important;
}
/* Mobile controls only on mobile */
@media (min-width: 1001px) {
  .pn-embed .joystick,
  .pn-embed #mobile-controls,
  .pn-embed .mobile-controls,
  .pn-embed [class*="joystick"],
  .pn-embed [id*="joystick"] {
    display: none !important;
    pointer-events: none !important;
  }
}
</style>

</head>
<body>
  <div class="topbar">
    <button class="btn" id="px-exit">EXIT</button>
    <div class="badge" id="px-badge" title="Click to change initials on home page">???</div>
  </div>

  <div class="layout">
    <aside class="panel">
      <h3 class="title">HOW TO PLAY</h3>
      <div class="muted">
        <p><b>Move:</b> WASD (or left stick)</p>
        <p><b>Shoot:</b> Arrow Keys (or right stick)</p>
        <p><b>Goal:</b> Protect humans, clear waves, climb levels.</p>
      </div>
      <div class="lb-meta">Initials are set on the homepage. Click the badge (top-right) to change.</div>
    </aside>

    <main class="panel gamewrap">
      <h3 class="title">ROBO-ARENA</h3>
      <div class="gamebox" id="px-gamebox">
        <div id="game-container">
          <canvas id="gameCanvas"></canvas>

          <div id="ui-layer">
            <div class="hud-top">
              <div class="hud-score">SCORE: <span id="scoreDisplay">0</span></div>
              <div class="hud-level">LEVEL: <span id="levelDisplay">1</span></div>
              <div class="hud-lives">LIVES: <span id="livesDisplay">3</span></div>
            </div>
          </div>

          <div id="start-screen">
            <h1>ROBO-ARENA</h1>
            <p>Protect Humans. Destroy Robots.<br>Aliens appear Level 2+.</p>

            <div class="controls-info">
              <div class="key-group">
                <div>MOVE</div>
                <div><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span></div>
              </div>
              <div class="key-group">
                <div>SHOOT</div>
                <div><span class="key">ARROWS</span></div>
              </div>
            </div>

            <div class="leaderboard">
              <h3>Top Agents</h3>
              <div id="score-list"></div>
            </div>

            <button class="btn2" id="startBtn">INSERT COIN</button>
          </div>

          <div id="game-over-screen" class="hidden">
            <h1 style="color:#fff">GAME OVER</h1>
            <p>FINAL SCORE: <span id="finalScore" style="color:#0ff; font-size:1.5rem">0</span></p>
            <div id="standard-game-over-controls">
              <button class="btn2" id="restartBtn">TRY AGAIN</button>
            </div>
          </div>

          <div id="mobile-controls">
            <div class="joystick-zone" id="stick-move">
              <div class="joystick-knob" id="knob-move"></div>
            </div>
            <div class="joystick-zone" id="stick-aim">
              <div class="joystick-knob" id="knob-aim"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="muted">Backend leaderboard + auto-save on game over.</div>
    </main>

    <aside class="panel">
      <h3 class="title">LEADERBOARD</h3>
      <div id="px-lb" class="muted">Loadingâ€¦</div>
    </aside>
  </div>

  <script src="../../js/engine.js"></script>
  <script>
    (function(){
      const SLUG = "robo-arena";
      const ls = localStorage.getItem("px_player_initials") || "";
      if(ls) sessionStorage.setItem("playerInitials", ls);
      if(window.PixelNet && PixelNet.init) PixelNet.init();

      const badge = document.getElementById("px-badge");
      badge.textContent = ls || "???";
      badge.onclick = () => location.href = "../../index.html";
      document.getElementById("px-exit").onclick = () => location.href = "../../index.html";

      function renderRows(rows){
        const top = (rows || []).slice(0, 10);
        if(top.length === 0){
          return '<div class="muted">No scores yet.</div>';
        }
        return top.map((r, i) => {
          const name = (r.initials || r.name || "---").toString().toUpperCase().slice(0,3);
          const val = Math.max(0, Math.floor(Number(r.score) || 0));
          return `<div class="score-row">
            <div><span class="score-rank">#${i+1}</span><span class="score-name">${name}</span></div>
            <span class="score-val">${val}</span>
          </div>`;
        }).join("");
      }

      async function renderLeaderboard(){
        try{
          const rows = (window.PixelNet && PixelNet.getLeaderboard) ? await PixelNet.getLeaderboard(SLUG) : [];
          document.getElementById("px-lb").innerHTML = renderRows(rows);
          document.getElementById("score-list").innerHTML = renderRows(rows.slice(0,5));
        }catch(e){
          console.warn("[robo-arena] leaderboard failed", e);
          document.getElementById("px-lb").innerHTML = '<div class="muted">Offline</div>';
          document.getElementById("score-list").innerHTML = '<div class="muted">Offline</div>';
        }
      }

      renderLeaderboard();
      window.__pxRenderRoboLeaderboard = renderLeaderboard;

      // Prevent page scroll while touching the gamebox (mobile)
      const gb = document.getElementById("px-gamebox");
      if(gb){
        gb.addEventListener("touchmove", (e)=>{ e.preventDefault(); }, {passive:false});
      }

      // Expose slug for game script
      window.__PX_GAME_SLUG__ = SLUG;
    })();
  </script>

  <script>
/**
 * ROBO-ARENA (canonical)
 * Minimal changes: backend leaderboard + auto-save on GAME OVER (no initials)
 */

// --- Audio System ---
const AudioSys = (() => {
    let ctx = null;
    let masterGain = null;

    function init() {
        if (!ctx) {
            ctx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = ctx.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(ctx.destination);
        }
        if (ctx.state === 'suspended') ctx.resume();
    }

    function playTone(freq, type, duration, vol = 1, slideTo = null) {
        if (!ctx) return;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        if (slideTo) osc.frequency.exponentialRampToValueAtTime(slideTo, ctx.currentTime + duration);

        gain.gain.setValueAtTime(vol, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(masterGain);
        osc.start();
        osc.stop(ctx.currentTime + duration);
    }

    function shoot() { playTone(800, 'square', 0.1, 0.5, 300); }
    function enemyShoot() { playTone(400, 'sawtooth', 0.15, 0.5, 200); }
    function explosion() { playTone(100, 'sawtooth', 0.4, 0.8, 10); }
    function pickup() { playTone(1200, 'sine', 0.2, 0.6, 2000); }
    function levelUp() {
        setTimeout(() => playTone(600, 'square', 0.1, 0.6), 0);
        setTimeout(() => playTone(800, 'square', 0.1, 0.6), 100);
        setTimeout(() => playTone(1200, 'square', 0.4, 0.6), 200);
    }
    function die() { playTone(500, 'sawtooth', 1.0, 1.0, 50); }
    function highScore() {
        playTone(1000, 'square', 0.1, 0.5);
        setTimeout(() => playTone(1500, 'square', 0.1, 0.5), 100);
        setTimeout(() => playTone(2000, 'square', 0.2, 0.5), 200);
    }

    return { init, shoot, enemyShoot, explosion, pickup, levelUp, die, highScore };
})();

// --- Constants & Config ---
const TILE_SIZE = 40;

const COLORS = {
    PLAYER: '#0ff',
    HUMAN: '#f0f',
    GRUNT: '#f00',
    HULK: '#0f0',
    ENFORCER: '#ff9900',
    BULLET: '#ff0',
    ENEMY_BULLET: '#ff4400',
    OBSTACLE: '#333'
};

// --- Game Engine ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
ctx.shadowBlur = 0;

let animationId;
let lastTime = 0;

// Game State
const state = {
    active: false,
    level: 1,
    score: 0,
    lives: 3,
    entities: [],
    particles: [],
    width: 0,
    height: 0,
    waveCompleteTimer: 0
};

// Input State
const input = {
    keys: {},
    move: { x: 0, y: 0 },
    aim: { x: 0, y: 0 },
    firing: false
};

// --- Classes ---
class Entity {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.radius = 10;
        this.dead = false;
        this.vx = 0;
        this.vy = 0;
        this.speed = 0;
        this.color = '#fff';
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        if (this.x < this.radius) this.x = this.radius;
        if (this.x > state.width - this.radius) this.x = state.width - this.radius;
        if (this.y < this.radius) this.y = this.radius;
        if (this.y > state.height - this.radius) this.y = state.height - this.radius;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.fillStyle = this.color;
        this.drawShape(ctx);
        ctx.restore();
    }

    drawShape(ctx) {
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 'player');
        this.speed = 250;
        this.color = COLORS.PLAYER;
        this.lastShot = 0;
        this.fireRate = 0.08;
        this.facing = 0;
        this.animTimer = 0;
    }

    update(dt) {
        this.vx = input.move.x * this.speed;
        this.vy = input.move.y * this.speed;

        if (this.vx !== 0 || this.vy !== 0) this.animTimer += dt * 15;
        else this.animTimer = 0;

        super.update(dt);

        if (input.aim.x !== 0 || input.aim.y !== 0) {
            this.facing = Math.atan2(input.aim.y, input.aim.x);
            this.lastShot -= dt;
            if (this.lastShot <= 0) {
                this.shoot();
                this.lastShot = this.fireRate;
            }
        } else if (input.move.x !== 0 || input.move.y !== 0) {
            this.facing = Math.atan2(input.move.y, input.move.x);
        }
    }

    shoot() {
        const dx = Math.cos(this.facing);
        const dy = Math.sin(this.facing);
        state.entities.push(new Bullet(this.x + dx * 15, this.y + dy * 15, dx, dy, false));
        AudioSys.shoot();
    }

    draw(ctx) {
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        super.draw(ctx);
        ctx.shadowBlur = 0;
    }

    drawShape(ctx) {
        ctx.fillStyle = this.color;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;

        const legOffset = Math.sin(this.animTimer) * 6;

        ctx.save();
        ctx.rotate(this.facing);

        ctx.beginPath();
        ctx.moveTo(-4, 0);
        ctx.lineTo(-8 - legOffset, 0);
        ctx.moveTo(-4, 0);
        ctx.lineTo(-8 + legOffset, 0);
        ctx.stroke();

        ctx.fillRect(-6, -6, 12, 12);

        ctx.beginPath();
        ctx.arc(0, 0, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();

        ctx.fillStyle = this.color;
        ctx.fillRect(4, -2, 14, 4);

        ctx.restore();
    }
}

class Bullet extends Entity {
    constructor(x, y, dx, dy, isEnemy = false) {
        super(x, y, isEnemy ? 'enemy_bullet' : 'bullet');
        this.isEnemy = isEnemy;
        this.vx = dx * (isEnemy ? 300 : 800);
        this.vy = dy * (isEnemy ? 300 : 800);
        this.radius = 4;
        this.color = isEnemy ? COLORS.ENEMY_BULLET : COLORS.BULLET;
        this.life = 1.5;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt;
        if (this.life <= 0) this.dead = true;
        if (this.x < 0 || this.x > state.width || this.y < 0 || this.y > state.height) this.dead = true;
    }

    drawShape(ctx) {
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

class Grunt extends Entity {
    constructor(x, y) {
        super(x, y, 'grunt');
        this.speed = 100 + (state.level * 10);
        this.radius = 14;
        this.color = COLORS.GRUNT;
        this.animTimer = 0;
    }

    update(dt) {
        this.animTimer += dt * 5;
        const player = getPlayer();
        if (!player) return;

        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist > 0) {
            this.vx = (dx / dist) * this.speed;
            this.vy = (dy / dist) * this.speed;
        }
        super.update(dt);
    }

    drawShape(ctx) {
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;

        ctx.strokeRect(-10, -10, 20, 20);

        ctx.fillStyle = '#fff';
        const blink = Math.sin(this.animTimer * 10) > 0.8;
        if (!blink) {
            ctx.fillRect(-6, -4, 4, 4);
            ctx.fillRect(2, -4, 4, 4);
        }

        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(0, -16);
        ctx.stroke();

        const w = Math.sin(this.animTimer * 20) * 4;
        ctx.beginPath();
        ctx.moveTo(-8, 10);
        ctx.lineTo(-8, 16 + w);
        ctx.moveTo(8, 10);
        ctx.lineTo(8, 16 - w);
        ctx.stroke();

        ctx.shadowBlur = 0;
    }
}

class Hulk extends Entity {
    constructor(x, y) {
        super(x, y, 'hulk');
        this.speed = 60 + (state.level * 5);
        this.radius = 20;
        this.color = COLORS.HULK;
        this.dirChangeTimer = 0;
        this.animTimer = 0;
    }

    update(dt) {
        this.animTimer += dt * 3;
        this.dirChangeTimer -= dt;

        let target = null;
        let minDist = 250;

        state.entities.forEach(e => {
            if (e.type === 'human') {
                const d = Math.hypot(e.x - this.x, e.y - this.y);
                if (d < minDist) { minDist = d; target = e; }
            }
        });

        if (target) {
            const dx = target.x - this.x;
            const dy = target.y - this.y;
            this.vx = (dx / minDist) * this.speed;
            this.vy = (dy / minDist) * this.speed;
        } else if (this.dirChangeTimer <= 0) {
            const angle = Math.random() * Math.PI * 2;
            this.vx = Math.cos(angle) * this.speed;
            this.vy = Math.sin(angle) * this.speed;
            this.dirChangeTimer = 1.0;
        }

        super.update(dt);
    }

    drawShape(ctx) {
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;

        const pulse = Math.sin(this.animTimer) * 2;
        ctx.fillRect(-16 - pulse, -18, 32 + pulse*2, 30);

        ctx.fillStyle = '#0a0';
        ctx.fillRect(-20, 8, 12, 10);
        ctx.fillRect(8, 8, 12, 10);

        ctx.fillStyle = '#000';
        ctx.fillRect(-12, -10, 24, 8);

        ctx.fillStyle = '#f00';
        ctx.fillRect(-8, -8, 6, 4);
        ctx.fillRect(2, -8, 6, 4);

        ctx.shadowBlur = 0;
    }
}

class Enforcer extends Entity {
    constructor(x, y) {
        super(x, y, 'enforcer');
        this.speed = 120 + (state.level * 5);
        this.radius = 14;
        this.color = COLORS.ENFORCER;
        this.fireTimer = 2.0 + Math.random();
        this.moveTimer = 0;
    }

    update(dt) {
        this.moveTimer += dt;
        const player = getPlayer();

        if (player) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist > 0) {
                this.vx = (dx / dist) * this.speed + Math.sin(this.moveTimer * 3) * 50;
                this.vy = (dy / dist) * this.speed + Math.cos(this.moveTimer * 2) * 50;
            }

            this.fireTimer -= dt;
            if (this.fireTimer <= 0 && dist < 500) {
                const angle = Math.atan2(dy, dx);
                state.entities.push(new Bullet(this.x, this.y, Math.cos(angle), Math.sin(angle), true));
                this.fireTimer = 2.0 - Math.min(1.5, state.level * 0.1);
                AudioSys.enemyShoot();
            }
        }

        super.update(dt);
    }

    drawShape(ctx) {
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.moveTo(0, -12);
        ctx.lineTo(12, 0);
        ctx.lineTo(0, 12);
        ctx.lineTo(-12, 0);
        ctx.closePath();
        ctx.stroke();

        const s = 4 + Math.sin(this.moveTimer * 10) * 2;
        ctx.fillStyle = '#fff';
        ctx.fillRect(-s/2, -s/2, s, s);

        ctx.shadowBlur = 0;
    }
}

class Human extends Entity {
    constructor(x, y) {
        super(x, y, 'human');
        this.speed = 40;
        this.radius = 10;
        this.color = COLORS.HUMAN;
        this.changeTimer = 0;
        this.walkAnim = 0;
    }

    update(dt) {
        this.walkAnim += dt * 10;
        this.changeTimer -= dt;
        if (this.changeTimer <= 0) {
            const angle = Math.random() * Math.PI * 2;
            this.vx = Math.cos(angle) * this.speed;
            this.vy = Math.sin(angle) * this.speed;
            this.changeTimer = 1.0;
        }

        if (this.x < 30) this.vx = Math.abs(this.vx);
        if (this.x > state.width - 30) this.vx = -Math.abs(this.vx);
        if (this.y < 30) this.vy = Math.abs(this.vy);
        if (this.y > state.height - 30) this.vy = -Math.abs(this.vy);

        super.update(dt);
    }

    drawShape(ctx) {
        ctx.shadowBlur = 8;
        ctx.shadowColor = this.color;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, -8, 5, 0, Math.PI*2);
        ctx.moveTo(0, -3);
        ctx.lineTo(0, 8);
        const legSwing = Math.sin(this.walkAnim) * 5;
        ctx.lineTo(-6 + legSwing, 16);
        ctx.moveTo(0, 8);
        ctx.lineTo(6 - legSwing, 16);
        ctx.moveTo(0, 0);
        ctx.lineTo(-6 - legSwing/2, 6);
        ctx.moveTo(0, 0);
        ctx.lineTo(6 + legSwing/2, 6);
        ctx.stroke();
        ctx.shadowBlur = 0;
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 150 + 50;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 0.5 + Math.random() * 0.3;
        this.size = Math.random() * 3 + 1;
    }

    update(dt) { this.x += this.vx * dt; this.y += this.vy * dt; this.life -= dt; }

    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

// --- Utils ---
function getPlayer() { return state.entities.find(e => e.type === 'player'); }

function spawnExplosion(x, y, color, count = 10) {
    for(let i=0; i<count; i++) state.particles.push(new Particle(x, y, color));
}

function checkCollision(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    return dist < (a.radius + b.radius);
}

// --- Level Generation ---
function startLevel(levelNum) {
    state.entities = [];
    state.particles = [];
    state.level = levelNum;
    state.waveCompleteTimer = 0;

    state.entities.push(new Player(state.width/2, state.height/2));

    const gruntCount = 5 + (levelNum * 4);
    const hulkCount = Math.floor(levelNum * 0.8) + 1;
    const enforcerCount = levelNum >= 2 ? (levelNum - 1) * 2 : 0;
    const humanCount = Math.min(10, 2 + Math.floor(levelNum / 2));

    const safeDist = 200;
    const cx = state.width/2;
    const cy = state.height/2;

    function getSpawnPos() {
        let x, y, d;
        let attempts = 0;
        do {
            x = Math.random() * (state.width - 60) + 30;
            y = Math.random() * (state.height - 60) + 30;
            d = Math.hypot(x - cx, y - cy);
            attempts++;
            if (attempts > 50) return {x: 50, y: 50};
        } while(d < safeDist);
        return {x, y};
    }

    for(let i=0; i<gruntCount; i++) {
        const pos = getSpawnPos();
        state.entities.push(new Grunt(pos.x, pos.y));
    }

    for(let i=0; i<hulkCount; i++) {
        const pos = getSpawnPos();
        state.entities.push(new Hulk(pos.x, pos.y));
    }

    for(let i=0; i<enforcerCount; i++) {
        const pos = getSpawnPos();
        state.entities.push(new Enforcer(pos.x, pos.y));
    }

    for(let i=0; i<humanCount; i++) {
        const pos = getSpawnPos();
        state.entities.push(new Human(pos.x, pos.y));
    }

    updateHUD();
    AudioSys.levelUp();
}

// --- Main Loop ---
function update(dt) {
    let kMoveX = 0, kMoveY = 0, kAimX = 0, kAimY = 0;

    if (input.keys['w']) kMoveY -= 1;
    if (input.keys['s']) kMoveY += 1;
    if (input.keys['a']) kMoveX -= 1;
    if (input.keys['d']) kMoveX += 1;

    if (input.keys['arrowup']) kAimY -= 1;
    if (input.keys['arrowdown']) kAimY += 1;
    if (input.keys['arrowleft']) kAimX -= 1;
    if (input.keys['arrowright']) kAimX += 1;

    input.move.x = kMoveX;
    input.move.y = kMoveY;
    input.aim.x = kAimX;
    input.aim.y = kAimY;

    if (input.touchMove && (input.touchMove.x !== 0 || input.touchMove.y !== 0)) input.move = input.touchMove;
    if (input.touchAim && (input.touchAim.x !== 0 || input.touchAim.y !== 0)) input.aim = input.touchAim;

    state.entities.forEach(e => e.update(dt));
    state.particles.forEach(p => p.update(dt));

    state.entities = state.entities.filter(e => !e.dead);
    state.particles = state.particles.filter(p => p.life > 0);

    const player = getPlayer();
    const playerBullets = state.entities.filter(e => e.type === 'bullet');
    const enemyBullets = state.entities.filter(e => e.type === 'enemy_bullet');
    const enemies = state.entities.filter(e => ['grunt', 'hulk', 'enforcer'].includes(e.type));
    const humans = state.entities.filter(e => e.type === 'human');

    playerBullets.forEach(b => {
        enemies.forEach(e => {
            if (b.dead || e.dead) return;
            if (checkCollision(b, e)) {
                b.dead = true;
                if (e.type === 'grunt') {
                    e.dead = true; state.score += 100;
                    spawnExplosion(e.x, e.y, COLORS.GRUNT);
                    AudioSys.explosion();
                } else if (e.type === 'enforcer') {
                    e.dead = true; state.score += 500;
                    spawnExplosion(e.x, e.y, COLORS.ENFORCER);
                    AudioSys.explosion();
                } else if (e.type === 'hulk') {
                    e.x += b.vx * dt * 0.2;
                    e.y += b.vy * dt * 0.2;
                }
            }
        });
    });

    if (player) {
        enemies.forEach(e => { if (checkCollision(player, e)) killPlayer(); });
        enemyBullets.forEach(b => { if (checkCollision(player, b)) { b.dead = true; killPlayer(); } });
        humans.forEach(h => {
            if (checkCollision(player, h)) {
                h.dead = true; state.score += 1000;
                spawnExplosion(h.x, h.y, COLORS.HUMAN, 20);
                AudioSys.pickup();
            }
        });
    }

    enemies.filter(e => e.type === 'hulk').forEach(hulk => {
        humans.forEach(human => {
            if (!human.dead && checkCollision(hulk, human)) {
                human.dead = true;
                spawnExplosion(human.x, human.y, '#f00', 30);
                AudioSys.die();
            }
        });
    });

    const hostileCount = state.entities.filter(e => e.type === 'grunt' || e.type === 'enforcer').length;
    if (hostileCount === 0 && player && !state.waveCompleteTimer) state.waveCompleteTimer = 2.0;

    if (state.waveCompleteTimer > 0) {
        state.waveCompleteTimer -= dt;
        if (state.waveCompleteTimer <= 0) startLevel(state.level + 1);
    }

    updateHUD();
}

function draw() {
    ctx.fillStyle = 'rgba(5, 5, 5, 0.4)';
    ctx.fillRect(0, 0, state.width, state.height);

    ctx.strokeStyle = '#222';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let x=0; x<=state.width; x+=TILE_SIZE) { ctx.moveTo(x,0); ctx.lineTo(x, state.height); }
    for(let y=0; y<=state.height; y+=TILE_SIZE) { ctx.moveTo(0,y); ctx.lineTo(state.width, y); }
    ctx.stroke();

    state.entities.sort((a,b) => a.y - b.y);
    state.entities.forEach(e => e.draw(ctx));

    ctx.shadowBlur = 5;
    state.particles.forEach(p => { ctx.shadowColor = p.color; p.draw(ctx); });
    ctx.shadowBlur = 0;
}

function gameLoop(timestamp) {
    if (!state.active) return;

    if (!lastTime) lastTime = timestamp;
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    update(Math.min(dt, 0.1));
    draw();

    animationId = requestAnimationFrame(gameLoop);
}

// --- Game Control ---
let __scoreSubmitted = false;

function killPlayer() {
    const player = getPlayer();
    if (player) {
        spawnExplosion(player.x, player.y, COLORS.PLAYER, 50);
        player.dead = true;
        AudioSys.die();
        state.lives--;

        if (state.lives < 0) {
            gameOver();
        } else {
            setTimeout(() => {
                if (state.active) {
                    state.entities.push(new Player(state.width/2, state.height/2));
                    state.entities.forEach(e => {
                        if (e.type === 'grunt' || e.type === 'hulk' || e.type === 'enforcer') {
                            const d = Math.hypot(e.x - state.width/2, e.y - state.height/2);
                            if (d < 150) e.dead = true;
                        }
                    });
                }
            }, 1500);
        }
    }
}

function gameOver() {
    state.active = false;
    document.getElementById('game-over-screen').classList.remove('hidden');
    const final = Math.max(0, Math.floor(state.score || 0));
    document.getElementById('finalScore').innerText = final;

    // Submit once to backend (no initials)
    if(!__scoreSubmitted && window.PixelNet && PixelNet.submitScore){
      __scoreSubmitted = true;
      try{
        PixelNet.submitScore(window.__PX_GAME_SLUG__ || "robo-arena", final);
        if(window.__pxRenderRoboLeaderboard) setTimeout(window.__pxRenderRoboLeaderboard, 800);
      }catch(e){
        console.warn("[robo-arena] submit failed", e);
      }
    }
}

function resetGame() {
    state.score = 0;
    state.lives = 3;
    state.level = 1;
    state.entities = [];
    state.active = true;
    state.waveCompleteTimer = 0;
    lastTime = 0;
    __scoreSubmitted = false;

    input.keys = {};
    input.move = {x:0, y:0};
    input.aim = {x:0, y:0};

    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('game-over-screen').classList.add('hidden');

    resize();
    AudioSys.init();
    startLevel(1);
    gameLoop(0);
}

function updateHUD() {
    document.getElementById('scoreDisplay').innerText = state.score;
    document.getElementById('levelDisplay').innerText = state.level;
    document.getElementById('livesDisplay').innerText = state.lives >= 0 ? state.lives : 0;
}

// Resize to gamebox (not full window)
function resize() {
    const box = document.getElementById("px-gamebox");
    const rect = box ? box.getBoundingClientRect() : null;
    state.width = rect ? Math.floor(rect.width) : window.innerWidth;
    state.height = rect ? Math.floor(rect.height) : window.innerHeight;
    canvas.width = state.width;
    canvas.height = state.height;
}

window.addEventListener('keydown', (e) => {
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].indexOf(e.code) > -1) e.preventDefault();
    input.keys[e.key.toLowerCase()] = true;
});
window.addEventListener('keyup', (e) => { input.keys[e.key.toLowerCase()] = false; });

window.addEventListener('blur', () => {
    input.keys = {};
    input.move = {x:0, y:0};
    input.aim = {x:0, y:0};
});

window.addEventListener('resize', () => { resize(); });

// Joystick Logic (unchanged)
function setupJoystick(elementId, knobId, inputTarget) {
    const zone = document.getElementById(elementId);
    const knob = document.getElementById(knobId);

    let touchId = null;
    const maxDist = 35;

    zone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        touchId = touch.identifier;
        updateJoystick(touch.clientX, touch.clientY);
    }, {passive: false});

    zone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        for (let i=0; i<e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === touchId) updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
        }
    }, {passive: false});

    const endTouch = (e) => {
        e.preventDefault();
        for (let i=0; i<e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === touchId) {
                touchId = null;
                knob.style.transform = `translate(-50%, -50%)`;
                input[inputTarget] = {x:0, y:0};
            }
        }
    };

    zone.addEventListener('touchend', endTouch);
    zone.addEventListener('touchcancel', endTouch);

    function updateJoystick(cx, cy) {
        const rect = zone.getBoundingClientRect();
        const centerX = rect.left + rect.width/2;
        const centerY = rect.top + rect.height/2;

        let dx = cx - centerX;
        let dy = cy - centerY;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist > maxDist) {
            dx = (dx / dist) * maxDist;
            dy = (dy / dist) * maxDist;
        }

        knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

        input[inputTarget] = { x: dx / maxDist, y: dy / maxDist };
    }
}

setupJoystick('stick-move', 'knob-move', 'touchMove');
setupJoystick('stick-aim', 'knob-aim', 'touchAim');

document.getElementById('startBtn').addEventListener('click', () => { AudioSys.init(); resetGame(); });
document.getElementById('restartBtn').addEventListener('click', () => { resetGame(); });

// Initial Setup
resize();
if(window.__pxRenderRoboLeaderboard) window.__pxRenderRoboLeaderboard();
  </script>
</body>
</html>
