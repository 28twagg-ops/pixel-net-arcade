<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Neon Chase</title>

  <!-- PIXEL-NET Engine -->
  <script src="../../js/engine.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

    /* ========= PIXEL-NET WRAPPER (local, so it won't depend on global CSS) ========= */
    :root{
      --pn-bg:#050010;
      --pn-panel: rgba(5, 0, 16, 0.75);
      --pn-border: rgba(255,255,255,0.10);
      --pn-cyan:#00F0FF;
      --pn-green:#00FF41;
      --pn-pink:#FF0055;
      --pn-muted:#9aa0b3;
    }

    body{
      margin:0;
      background: var(--pn-bg);
      color:#fff;
      font-family:'Orbitron', sans-serif;
      /* IMPORTANT:
         - Desktop users must be able to scroll normally.
         - On mobile, we only block scroll *inside the game surface*.
      */
      overflow:auto;
      touch-action:manipulation;
      -webkit-user-select:none;
      user-select:none;
    }

    .play-shell{
      height:100vh;
      display:flex;
      flex-direction:column;
    }

    .play-topbar{
      display:flex;
      align-items:center;
      gap:12px;
      padding:10px 12px;
      background: rgba(5, 0, 16, 0.85);
      border-bottom: 1px solid rgba(255,255,255,0.06);
      z-index:10;
      flex:0 0 auto;
    }

    .exit-btn{
      text-decoration:none;
      color: var(--pn-cyan);
      border: 1px solid rgba(0,240,255,0.35);
      padding:6px 10px;
      border-radius:10px;
      box-shadow: 0 0 12px rgba(0,240,255,0.18);
      font-size:12px;
      letter-spacing:1px;
    }

    .play-title{
      display:flex;
      align-items:baseline;
      gap:8px;
      font-size:12px;
    }
    .play-title .muted{ color: var(--pn-muted); }
    .play-title strong{ color: var(--pn-cyan); letter-spacing:1px; }

    .play-grid{
      flex:1 1 auto;
      display:grid;
      grid-template-columns: 300px 1fr 300px;
      grid-template-areas: "how game lb";
      gap:12px;
      padding:12px;
      box-sizing:border-box;
      align-items:stretch;
      min-height:0;
    }

    .panel-how{ grid-area: how; }
    .panel-lb{ grid-area: lb; }
    .center-wrap{ grid-area: game; }

    .panel{
      background: var(--pn-panel);
      border: 1px solid var(--pn-border);
      border-radius:12px;
      padding:12px;
      box-sizing:border-box;
      min-height:0;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
    }

    .panel h3{
      margin:0 0 10px 0;
      font-size:14px;
      letter-spacing:1px;
      color: var(--pn-pink);
      text-shadow: 0 0 6px rgba(255,0,85,0.30);
    }

    .panel ul{
      margin:0;
      padding-left:18px;
      font-size:12px;
      line-height:1.6;
      color:#d6d6d6;
    }

    .lb-status{
      font-size:11px;
      color: var(--pn-muted);
      margin-bottom:8px;
    }

    .lb-list{
      margin:0;
      padding-left:18px;
      font-size:12px;
      line-height:1.55;
      color:#e8e8e8;
    }

    .lb-list li{
      margin:4px 0;
    }

    .center-wrap{
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:0;
    }

    /* Mobile: put GAME first, then panels (so the full game is visible immediately).
       Keep panels compact but scrollable. */
    @media (max-width: 980px){
      .play-grid{
        grid-template-columns: 1fr;
        grid-template-areas:
          "game"
          "how"
          "lb";
      }
      .panel{ max-height: 18vh; }
      .center-wrap{ min-height: 56vh; }
    }

    /* ========= GAME CSS (your original, preserved) ========= */
    #game-container {
      position: relative;
      box-shadow: 0 0 30px rgba(0, 255, 65, 0.3);
      border: 4px solid #333;
      border-radius: 8px;
      background-color: #000;
    }

    #game-container{ touch-action:none; }
    canvas {
      display: block;
      background-color: #080808;
      touch-action:none; /* stop scroll gestures INSIDE the game */
      max-width:100%;
      max-height:100%;
      width:100%;
      height:auto;
    }

    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .hud-bar {
      display: flex;
      justify-content: space-between;
      padding: 10px 15px;
      font-size: 14px;
      text-shadow: 0 0 5px #0ff;
      z-index: 10;
    }

    #score-display span { color: #00F0FF; }
    #lives-display span { color: #FF0055; }
    #level-display span { color: #00FF41; }

    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(5, 0, 16, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      pointer-events: auto;
      text-align: center;
    }

    h1 {
      color: #00F0FF;
      font-size: 32px;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #00F0FF;
      letter-spacing: 2px;
      line-height: 1.5;
    }

    p {
      font-size: 12px;
      color: #aaa;
      line-height: 1.6;
      margin-bottom: 20px;
      max-width: 80%;
    }

    button {
      background: transparent;
      color: #00FF41;
      border: 2px solid #00FF41;
      padding: 15px 30px;
      font-family: 'Orbitron', sans-serif;
      font-size: 16px;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0, 255, 65, 0.2);
      transition: all 0.2s;
      margin-top: 10px;
      text-transform: uppercase;
    }

    button:hover {
      background: #00FF41;
      color: #000;
      box-shadow: 0 0 20px rgba(0, 255, 65, 0.6);
    }

    .hidden {
      display: none !important;
    }

    .mobile-hint {
      margin-top: 10px;
      font-size: 10px;
      color: #666;
      display: none;
    }

    @media (max-width: 600px) {
      .mobile-hint { display: block; }
    }
  </style>
</head>

<body>
  <div class="play-shell">
    <header class="play-topbar">
      <a class="exit-btn" href="../../index.html">✕ EXIT</a>
      <div class="play-title">
        <span class="muted">PLAYER</span> <strong id="playInitials">---</strong>
      </div>
    </header>

    <div class="play-grid">
      <aside class="panel panel-how">
        <h3>How to Play</h3>
        <ul>
          <li>Move: Arrow Keys / Swipe</li>
          <li>Collect Bits (+10)</li>
          <li>Power Bit (+50) → Hack drones</li>
          <li>Clear all bits to advance Zones</li>
        </ul>
      </aside>

      <main class="center-wrap">
        <div id="game-container">
          <canvas id="gameCanvas"></canvas>

          <div id="ui-layer">
            <div class="hud-bar">
              <div id="score-display">BITS: <span id="score-val">0</span></div>
              <div id="level-display">ZONE: <span id="level-val">1</span></div>
              <div id="high-score">TOP: <span id="high-score-val">0</span></div>
            </div>
            <div class="hud-bar" style="justify-content: flex-end;">
              <div id="lives-display">UNITS: <span id="lives-val">3</span></div>
            </div>
          </div>

          <div id="overlay"><!-- injected by JS --></div>
        </div>
      </main>

      <aside class="panel panel-lb">
        <h3>Leaderboard</h3>
        <div id="lbStatus" class="lb-status">Loading…</div>
        <ol id="lbList" class="lb-list"></ol>
      </aside>
    </div>
  </div>

<script>
/**
 * NEON CHASE (PIXEL-NET INTEGRATION)
 * Your gameplay is preserved; only leaderboard/initials are moved to PIXEL-NET backend.
 */

/* ========= PIXEL-NET SCORE + LB ========= */
const GAME_SLUG = "neon-chase";
let scoreSubmitted = false;

function getInitialsFromStorage() {
  return (localStorage.getItem("px_initials") || localStorage.getItem("pixelnet_initials") || "???")
    .toUpperCase().slice(0, 3);
}

async function refreshLeaderboard() {
  const status = document.getElementById("lbStatus");
  const list = document.getElementById("lbList");
  if (!status || !list || !window.PixelNet) return;

  status.textContent = "Loading…";
  list.innerHTML = "";

  try {
    const data = await PixelNet.getLeaderboard(GAME_SLUG);
    const entries = (data && data.entries) ? data.entries : (Array.isArray(data) ? data : []);

    const topScore = entries.length ? (entries[0].score ?? 0) : 0;
    highScore = Number(topScore) || 0;
    document.getElementById("high-score-val").textContent = highScore;

    entries.slice(0, 10).forEach((e, idx) => {
      const li = document.createElement("li");
      const name = (e.name || e.initials || "???").toString().toUpperCase().slice(0, 3);
      const sc = Number(e.score) || 0;
      li.textContent = `${idx + 1}. ${name} — ${sc}`;
      list.appendChild(li);
    });

    status.textContent = entries.length ? "" : "No scores yet.";
  } catch (err) {
    status.textContent = "Leaderboard failed to load.";
    console.log("[NEON-CHASE] leaderboard error:", err);
  }
}

/**
 * AUDIO ENGINE
 * Updated sounds for a "tech" feel
 */
const AudioEngine = (() => {
    let ctx = null;
    let enabled = false;

    const init = () => {
        if (!ctx) {
            ctx = new (window.AudioContext || window.webkitAudioContext)();
            enabled = true;
        } else if (ctx.state === 'suspended') {
            ctx.resume();
        }
    };

    const playTone = (freq, type, duration, vol = 0.1) => {
        if (!enabled || !ctx) return;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        gain.gain.setValueAtTime(vol, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + duration);
    };

    return {
        init,
        step: () => { // "Tick" instead of Waka
            if (!enabled) return;
            playTone(800, 'square', 0.05, 0.02);
        },
        eatDrone: () => playTone(1200, 'sawtooth', 0.1, 0.1),
        crash: () => {
            if (!enabled) return;
            for(let i=0; i<5; i++) {
                setTimeout(() => playTone(100 - (i*20), 'sawtooth', 0.2, 0.2), i*50);
            }
        },
        start: () => {
            if (!enabled) return;
            playTone(440, 'sine', 0.1, 0.1);
            setTimeout(() => playTone(880, 'sine', 0.3, 0.1), 150);
        }
    };
})();

const TILE_SIZE = 24; 
const WALL_COLOR = '#00FF41'; // Matrix Green
const GATE_COLOR = '#FF0055';

// 0: Empty, 1: Wall, 2: Bit, 3: Power Up, 4: Drone Gate
const MAP = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,1,2,1,1,2,1,2,1,1,2,1,1,1,2,1],
    [1,3,1,1,1,2,1,1,2,1,2,1,1,2,1,1,1,3,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,1,2,1,2,1,1,1,2,1,2,1,1,1,2,1],
    [1,2,2,2,2,2,1,2,2,1,2,2,1,2,2,2,2,2,1],
    [1,1,1,1,1,2,1,1,0,1,0,1,1,2,1,1,1,1,1],
    [0,0,0,0,1,2,1,0,0,4,0,0,1,2,1,0,0,0,0],
    [1,1,1,1,1,2,1,0,1,1,1,0,1,2,1,1,1,1,1],
    [0,2,2,2,2,2,0,0,1,0,1,0,0,2,2,2,2,2,0],
    [1,1,1,1,1,2,1,0,1,1,1,0,1,2,1,1,1,1,1],
    [0,0,0,0,1,2,1,0,0,0,0,0,1,2,1,0,0,0,0],
    [1,1,1,1,1,2,1,2,1,1,1,2,1,2,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
    [1,3,2,1,2,2,2,2,2,0,2,2,2,2,2,1,2,3,1],
    [1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1],
    [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

const COLS = MAP[0].length;
const ROWS = MAP.length;

// Game State
let canvas, ctx;
let gameInterval;
let score = 0;
let level = 1;
let highScore = 0;
let lives = 3;
let gameState = 'START'; 
let powerModeTime = 0;
let flashTimer = 0;

// Entities
let player = {};
let drones = [];
let particles = [];
let bits = [];

// Input
let nextDir = { x: 0, y: 0 }; 
let touchStartX = 0;
let touchStartY = 0;

class Entity {
    constructor(x, y, color) {
        this.x = x * TILE_SIZE + TILE_SIZE/2;
        this.y = y * TILE_SIZE + TILE_SIZE/2;
        this.color = color;
        this.dir = { x: 0, y: 0 };
        this.speed = 2;
        this.radius = TILE_SIZE * 0.4;
    }
    getGridPos() {
        return { c: Math.floor(this.x / TILE_SIZE), r: Math.floor(this.y / TILE_SIZE) };
    }
    isCentered() {
        const threshold = 1.0;
        const centerX = (this.getGridPos().c * TILE_SIZE) + TILE_SIZE/2;
        const centerY = (this.getGridPos().r * TILE_SIZE) + TILE_SIZE/2;
        return Math.abs(this.x - centerX) < threshold && Math.abs(this.y - centerY) < threshold;
    }
    snapToGrid() {
        const p = this.getGridPos();
        this.x = p.c * TILE_SIZE + TILE_SIZE/2;
        this.y = p.r * TILE_SIZE + TILE_SIZE/2;
    }
    canMove(dx, dy) {
        const p = this.getGridPos();
        const nextC = p.c + dx;
        const nextR = p.r + dy;
        if (nextC < 0 || nextC >= COLS) return true;
        if (nextR >= 0 && nextR < ROWS) {
            const tile = MAP[nextR][nextC];
            return tile !== 1 && tile !== 4;
        }
        return false;
    }
    move() {
        if (this.x < 0) this.x = canvas.width;
        if (this.x > canvas.width) this.x = 0;
        this.x += this.dir.x * this.speed;
        this.y += this.dir.y * this.speed;
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, '#00F0FF'); // Cyan
        this.pulse = 0;
    }
    update() {
        if (this.isCentered()) {
            if (nextDir.x !== 0 || nextDir.y !== 0) {
                if (this.canMove(nextDir.x, nextDir.y)) {
                    this.snapToGrid();
                    this.dir = { ...nextDir };
                }
            }
            if (!this.canMove(this.dir.x, this.dir.y)) {
                this.snapToGrid();
                this.dir = { x: 0, y: 0 };
            }
        }
        this.move();

        if ((this.dir.x !== 0 || this.dir.y !== 0) && Math.random() < 0.1) {
             AudioEngine.step();
        }

        const p = this.getGridPos();
        if (p.r >= 0 && p.r < ROWS && p.c >= 0 && p.c < COLS) {
            const bitIndex = bits.findIndex(b => b.c === p.c && b.r === p.r);
            if (bitIndex !== -1) {
                const b = bits[bitIndex];
                bits.splice(bitIndex, 1);
                if (b.type === 2) score += 10;
                else if (b.type === 3) { score += 50; activatePowerMode(); }
                if (bits.length === 0) winGame();
            }
        }
    }
    draw() {
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * 0.4, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;
    }
}

class Drone extends Entity {
    constructor(x, y, color, type) {
        super(x, y, color);
        this.originalColor = color;
        this.type = type;
        let baseSpeed = 1.5;
        if (level >= 2) baseSpeed = 2.0;
        if (level >= 5) baseSpeed = 2.4; 
        this.speed = baseSpeed; 
        this.mode = 'SCATTER';
        this.dir = { x: 0, y: 0 };
        this.inHouse = true;
    }
    update() {
        if (this.isCentered()) {
            const options = [];
            const dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
            dirs.forEach(d => {
                if (d.x === -this.dir.x && d.y === -this.dir.y && this.dir.x !==0) return;
                const p = this.getGridPos();
                const nextC = p.c + d.x;
                const nextR = p.r + d.y;
                if (nextC >=0 && nextC < COLS && nextR >=0 && nextR < ROWS) {
                    const tile = MAP[nextR][nextC];
                    if (tile === 1) return;
                    if (tile === 4 && !this.inHouse) return;
                    options.push(d);
                }
            });
            if (options.length > 0) {
                if (this.mode === 'FRIGHTENED') {
                    this.dir = options[Math.floor(Math.random() * options.length)];
                } else {
                    if (this.mode === 'CHASE' && Math.random() > 0.4) {
                        let bestDir = options[0];
                        let minDist = 999999;
                        options.forEach(opt => {
                            const tx = (this.getGridPos().c + opt.x) * TILE_SIZE;
                            const ty = (this.getGridPos().r + opt.y) * TILE_SIZE;
                            const dist = Math.hypot(tx - player.x, ty - player.y);
                            if (dist < minDist) { minDist = dist; bestDir = opt; }
                        });
                        this.dir = bestDir;
                    } else {
                         this.dir = options[Math.floor(Math.random() * options.length)];
                    }
                }
                this.snapToGrid();
            } else {
                this.dir = { x: -this.dir.x, y: -this.dir.y };
            }
        }
        this.move();
        const dist = Math.hypot(this.x - player.x, this.y - player.y);
        if (dist < TILE_SIZE) {
            if (this.mode === 'FRIGHTENED') {
                AudioEngine.eatDrone();
                this.reset();
                score += 200;
                createParticles(this.x, this.y, this.originalColor);
            } else if (this.mode !== 'EATEN') {
                killPlayer();
            }
        }
    }
    reset() {
        this.x = 9 * TILE_SIZE + TILE_SIZE/2;
        this.y = 8 * TILE_SIZE + TILE_SIZE/2;
        this.mode = 'CHASE';
        this.dir = {x:0, y:-1};
        this.inHouse = true;
        let releaseTime = Math.max(500, 2000 - (level * 200));
        setTimeout(() => { this.inHouse = false; }, releaseTime);
    }
    draw() {
        const color = (this.mode === 'FRIGHTENED') ? 
                      ((flashTimer > 0 && Math.floor(Date.now() / 200) % 2 === 0) ? '#fff' : '#00f') : 
                      this.originalColor;
        ctx.fillStyle = color;

        const r = this.radius;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - r);
        ctx.lineTo(this.x + r, this.y + r);
        ctx.lineTo(this.x - r, this.y + r);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(this.x, this.y, r/3, 0, Math.PI*2);
        ctx.fill();
    }
}

function init() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    canvas.width = COLS * TILE_SIZE;
    canvas.height = ROWS * TILE_SIZE;

    document.getElementById("playInitials").textContent = getInitialsFromStorage();
    refreshLeaderboard();

    window.addEventListener('keydown', handleKey);
    /* Mobile: capture gestures ONLY inside the canvas so the page can scroll elsewhere */
    canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
    canvas.addEventListener('touchend', handleTouchEnd, {passive: false});

    showStartScreen();
    resetLevel();
    draw();
}

function showStartScreen() {
    gameState = 'START';
    scoreSubmitted = false;

    const ov = document.getElementById('overlay');
    ov.classList.remove('hidden');

    ov.innerHTML = `
        <h1>NEON CHASE</h1>
        <p>ARROWS / SWIPE to Move<br>Collect Bits & Hack Drones</p>
        <button onclick="startGame()">INITIATE</button>
        <div class="mobile-hint">Tip: Quick swipes. Don’t scroll.</div>
    `;

    refreshLeaderboard();
}

function resetLevel() {
    bits = [];
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (MAP[r][c] === 2) bits.push({c, r, type: 2});
            if (MAP[r][c] === 3) bits.push({c, r, type: 3});
        }
    }
    resetEntities();
}

function resetEntities() {
    player = new Player(9, 15);
    drones = [
        new Drone(9, 8, '#FF0055', 0),
        new Drone(8, 9, '#FF9900', 1),
        new Drone(10, 9, '#CC00FF', 2),
        new Drone(9, 9, '#FFFF00', 3)
    ];
    drones[0].inHouse = false;
    drones[0].dir = {x: -1, y: 0};
    nextDir = { x: 0, y: 0 };
}

function startGame() {
    AudioEngine.init();
    AudioEngine.start();
    document.getElementById('overlay').classList.add('hidden');
    score = 0;
    lives = 3;
    level = 1;
    scoreSubmitted = false;
    updateUI();
    gameState = 'PLAY';
    resetLevel();
    if (gameInterval) clearInterval(gameInterval);
    gameInterval = setInterval(gameLoop, 1000/60);
}

function winGame() {
    gameState = 'LEVEL_TRANSITION';
    AudioEngine.start();
    level++;

    const ov = document.getElementById('overlay');
    ov.classList.remove('hidden');
    ov.innerHTML = `<h1>ZONE ${level}</h1><p>SYNCING...</p>`;

    clearInterval(gameInterval);
    setTimeout(() => {
        ov.classList.add('hidden');
        gameState = 'PLAY';
        resetLevel();
        gameInterval = setInterval(gameLoop, 1000/60);
    }, 3000);
}

function gameOver() {
    gameState = 'GAMEOVER';
    clearInterval(gameInterval);

    const finalScore = Math.floor(score);

    if (!scoreSubmitted && window.PixelNet && Number.isFinite(finalScore)) {
        scoreSubmitted = true;
        PixelNet.submitScore(GAME_SLUG, finalScore);
        setTimeout(refreshLeaderboard, 900);
    }

    const ov = document.getElementById('overlay');
    ov.classList.remove('hidden');
    ov.innerHTML = `
        <h1 style="color:#FF0055">SYSTEM FAILURE</h1>
        <p>BITS: ${finalScore}</p>
        <button onclick="showStartScreen()">REBOOT</button>
    `;
}

function killPlayer() {
    lives--;
    updateUI();
    AudioEngine.crash();
    createParticles(player.x, player.y, '#00F0FF');
    if (lives <= 0) {
        gameOver();
    } else {
        resetEntities();
    }
}

function activatePowerMode() {
    let duration = Math.max(120, 600 - ((level-1) * 60));
    powerModeTime = duration;
    flashTimer = 0;
    drones.forEach(g => { if (g.mode !== 'EATEN') g.mode = 'FRIGHTENED'; });
}

function createParticles(x, y, color) {
    for(let i=0; i<8; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 5,
            vy: (Math.random() - 0.5) * 5,
            life: 30,
            color: color
        });
    }
}

function updateUI() {
    document.getElementById('score-val').textContent = score;
    document.getElementById('high-score-val').textContent = highScore;
    document.getElementById('lives-val').textContent = lives;
    document.getElementById('level-val').textContent = level;
}

function gameLoop() {
    if (gameState !== 'PLAY') return;
    player.update();
    drones.forEach(g => g.update());
    if (powerModeTime > 0) {
        powerModeTime--;
        if (powerModeTime < 120) flashTimer++;
        if (powerModeTime === 0) {
            drones.forEach(g => { if (g.mode === 'FRIGHTENED') g.mode = 'CHASE'; });
        }
    }
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
    }
    updateUI();
    draw();
}

function draw() {
    ctx.fillStyle = '#050010';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            const x = c * TILE_SIZE;
            const y = r * TILE_SIZE;
            if (MAP[r][c] === 1) {
                ctx.strokeStyle = WALL_COLOR;
                ctx.lineWidth = 1;
                ctx.strokeRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                ctx.shadowBlur = 5;
                ctx.shadowColor = WALL_COLOR;
                ctx.strokeRect(x + 4, y + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                ctx.shadowBlur = 0;
            } else if (MAP[r][c] === 4) {
                ctx.strokeStyle = GATE_COLOR;
                ctx.beginPath();
                ctx.moveTo(x, y + TILE_SIZE/2);
                ctx.lineTo(x + TILE_SIZE, y + TILE_SIZE/2);
                ctx.stroke();
            }
        }
    }

    bits.forEach(b => {
        const x = b.c * TILE_SIZE + TILE_SIZE/2;
        const y = b.r * TILE_SIZE + TILE_SIZE/2;
        ctx.fillStyle = '#00F0FF';
        if (b.type === 2) {
            ctx.fillRect(x-1, y-1, 2, 2);
        } else {
            if (Math.floor(Date.now() / 100) % 2 === 0) {
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    });

    player.draw();
    drones.forEach(g => g.draw());
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 3, 3);
    });
}

function handleKey(e) {
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].indexOf(e.code) > -1) {
        e.preventDefault();
    }
    switch(e.code) {
        case 'ArrowUp': nextDir = { x: 0, y: -1 }; break;
        case 'ArrowDown': nextDir = { x: 0, y: 1 }; break;
        case 'ArrowLeft': nextDir = { x: -1, y: 0 }; break;
        case 'ArrowRight': nextDir = { x: 1, y: 0 }; break;
    }
}

function handleTouchStart(e) {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
}

function handleTouchEnd(e) {
    const touchEndX = e.changedTouches[0].clientX;
    const touchEndY = e.changedTouches[0].clientY;
    const dx = touchEndX - touchStartX;
    const dy = touchEndY - touchStartY;
    if (Math.abs(dx) > Math.abs(dy)) {
        if (Math.abs(dx) > 30) nextDir = dx > 0 ? {x:1, y:0} : {x:-1, y:0};
    } else {
        if (Math.abs(dy) > 30) nextDir = dy > 0 ? {x:0, y:1} : {x:0, y:-1};
    }
}

init();
</script>
</body>
</html>
