<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Neon Chase | PIXEL-NET</title>
  <style>

    :root{
      --text:#e9ecff;
      --muted:#a7b0d6;
      --stroke: rgba(255,255,255,.10);
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --panel: rgba(15,19,36,.72);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(255,0,122,.14), transparent 60%),
        radial-gradient(900px 500px at 85% 20%, rgba(0,255,247,.12), transparent 55%),
        linear-gradient(180deg, #050611 0%, #060716 100%);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      /* Allow scrolling outside the game area on mobile */
      overflow:auto;
      touch-action:pan-y;
    }
    .topbar{
      width:min(1200px, 92vw);
      margin:14px auto 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .btn{
      font-family:"Orbitron", system-ui, sans-serif;
      letter-spacing:.10em;
      text-transform:uppercase;
      border:1px solid rgba(0,255,247,.40);
      background: rgba(0,255,247,.10);
      color:#00f3ff;
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
    }
    .btn:hover{ background: rgba(0,255,247,.16); box-shadow:0 0 14px rgba(0,243,255,.20); }

    .badge{
      font-family:"Orbitron", system-ui, sans-serif;
      letter-spacing:.12em;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.28);
      padding:10px 12px;
      border-radius:18px;
      cursor:pointer;
      color:var(--text);
    }

    .layout{
      width:min(1200px, 92vw);
      margin:0 auto 16px;
      display:grid;
      grid-template-columns: 320px 1fr 320px;
      gap:14px;
      height: calc(100vh - 86px);
      min-height: 520px;
    }
    .panel{
      border:1px solid var(--stroke);
      background: var(--panel);
      border-radius:18px;
      box-shadow: var(--shadow);
      padding:14px;
      overflow:hidden;
    }
    .title{
      margin:0 0 10px 0;
      font-family:"Orbitron", system-ui, sans-serif;
      letter-spacing:.10em;
      font-size:13px;
      color: rgba(233,236,255,.92);
    }
    .muted{ color:var(--muted); font-size:13px; line-height:1.35; }
    .lb-meta{ margin-top:10px; font-size:12px; color:var(--muted); opacity:.9; }

    .gamewrap{ display:flex; flex-direction:column; gap:10px; }
    .gamebox{
      position:relative;
      flex:1;
      min-height: 420px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.35);
      overflow:hidden;
      touch-action:none; /* capture touch for joysticks */
    }

    /* Robo Arena internal styles (scoped) */
    #game-container{
      position:absolute;
      inset:0;
      display:flex;
      justify-content:center;
      align-items:center;
      background: radial-gradient(circle, #1a1a1a 0%, #000 100%);
    }
    canvas{
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.15);
      border: 4px solid #222;
      background-color: #000;
      max-width:100%;
      max-height:100%;
    }
    #ui-layer{
      position:absolute;
      top:0; left:0;
      width:100%; height:100%;
      pointer-events:none;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
    }
    .hud-top{
      display:flex;
      justify-content:space-between;
      padding:10px 20px;
      font-size:20px;
      text-shadow:0 0 5px currentColor;
      background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
      font-family: 'Courier New', Courier, monospace;
    }
    .hud-score{ color:#0ff; }
    .hud-lives{ color:#f0f; }
    .hud-level{ color:#ff0; }

    #start-screen, #game-over-screen{
      position:absolute;
      inset:0;
      background: rgba(0,0,0,0.9);
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      pointer-events:auto;
      z-index:10;
      padding: 18px;
    }
    #game-over-screen.hidden{ display:none !important; }
    h1{
      font-size: 3rem;
      margin: 0 0 6px 0;
      color:#f00;
      text-transform:uppercase;
      text-shadow:4px 4px 0px #fff;
      letter-spacing:5px;
      text-align:center;
      font-family: 'Courier New', Courier, monospace;
    }
    p{
      font-size:1rem;
      margin: 0 0 16px 0;
      color:#ddd;
      text-align:center;
      line-height:1.4;
      max-width:600px;
      font-family: 'Courier New', Courier, monospace;
    }
    .btn2{
      background: transparent;
      color:#0f0;
      border:2px solid #0f0;
      padding:10px 30px;
      font-size:1.2rem;
      font-family: 'Courier New', Courier, monospace;
      cursor:pointer;
      text-transform:uppercase;
      transition: all 0.2s;
      box-shadow: 0 0 10px #0f0;
      margin-top: 12px;
    }
    .btn2:hover{ background:#0f0; color:#000; box-shadow:0 0 20px #0f0; }

    .controls-info{
      display:flex;
      gap:40px;
      margin-bottom:18px;
      font-size:0.8rem;
      color:#aaa;
      font-family: 'Courier New', Courier, monospace;
    }
    .key-group{text-align:center}
    .key{display:inline-block;border:1px solid #666;padding:2px 6px;border-radius:4px;color:#fff;background:#222}

    .leaderboard{
      margin-top: 8px;
      border:2px solid #444;
      padding: 15px;
      background: rgba(20,20,20,0.8);
      width: 300px;
      box-shadow: 0 0 15px rgba(0,255,255,0.1);
    }
    .leaderboard h3{
      color:#ff0;
      margin:0 0 10px 0;
      text-align:center;
      text-transform:uppercase;
      letter-spacing:2px;
      border-bottom:1px solid #444;
      padding-bottom:5px;
      font-family: 'Courier New', Courier, monospace;
    }
    .score-row{ display:flex; justify-content:space-between; margin:5px 0; font-family: monospace; font-size:1.1rem; }
    .score-rank{ color:#888; margin-right:10px; }
    .score-name{ color:#0ff; }
    .score-val{ color:#fff; }

    #mobile-controls{
      display:none;
      position:absolute;
      bottom: 14px;
      left:0;
      width:100%;
      height:150px;
      pointer-events:none;
      justify-content:space-between;
      padding:0 26px;
      box-sizing:border-box;
      z-index: 20;
    }
    .joystick-zone{
      width:120px; height:120px;
      background: rgba(255,255,255,0.10);
      border-radius:50%;
      border:2px solid rgba(255,255,255,0.30);
      position:relative;
      pointer-events:auto;
    }
    .joystick-knob{
      width:50px;height:50px;
      background: rgba(255,255,255,0.50);
      border-radius:50%;
      position:absolute;
      top:50%; left:50%;
      transform: translate(-50%, -50%);
      pointer-events:none;
    }

    @media (max-width: 1100px){
      .layout{ grid-template-columns: 1fr; height:auto; min-height:0; }
      body{ overflow:auto; }
      .gamebox{ min-height: 62vh; }
    }
    @media (max-width: 768px){
      h1{ font-size:2rem; }
      .controls-info{ display:none; }
      #mobile-controls{ display:flex; }
      .leaderboard{ width: 90%; font-size:0.9rem; }
    }
  
#game-container {
      position: relative;
      box-shadow: 0 0 30px rgba(0, 255, 65, 0.3);
      border: 4px solid #333;
      border-radius: 8px;
      background-color: #000;
    }

    #game-container canvas {
      display: block;
      background-color: #080808;
    }

    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .hud-bar {
      display: flex;
      justify-content: space-between;
      padding: 10px 15px;
      font-size: 14px;
      text-shadow: 0 0 5px #0ff;
      z-index: 10;
    }

    #score-display span { color: #00F0FF; }
    #lives-display span { color: #FF0055; }
    #level-display span { color: #00FF41; }

    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(5, 0, 16, 0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      pointer-events: auto;
      text-align: center;
    }

    h1 {
      color: #00F0FF;
      font-size: 32px;
      margin-bottom: 20px;
      text-shadow: 0 0 10px #00F0FF;
      letter-spacing: 2px;
      line-height: 1.5;
    }

    p {
      font-size: 12px;
      color: #aaa;
      line-height: 1.6;
      margin-bottom: 20px;
      max-width: 80%;
    }

    button {
      background: transparent;
      color: #00FF41;
      border: 2px solid #00FF41;
      padding: 15px 30px;
      font-family: 'Orbitron', sans-serif;
      font-size: 16px;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(0, 255, 65, 0.2);
      transition: all 0.2s;
      margin-top: 10px;
      text-transform: uppercase;
    }

    button:hover {
      background: #00FF41;
      color: #000;
      box-shadow: 0 0 20px rgba(0, 255, 65, 0.6);
    }

    .hidden {
      display: none !important;
    }

    .mobile-hint {
      margin-top: 10px;
      font-size: 10px;
      color: #666;
      display: none;
    }

    @media (max-width: 600px) {
      .mobile-hint { display: block; }
    }
  
  </style>

<!-- PIXEL-NET EMBED MODE (wrapper uses this) -->
<script>
(function(){
  try {
    var embed = (window.self !== window.top) || /[?&]embed=1\b/.test(location.search);
    if (embed) document.documentElement.classList.add("pn-embed");
  } catch(e) {
    document.documentElement.classList.add("pn-embed");
  }
})();
</script>
<style>
/* When embedded inside the canonical wrapper, show ONLY the game surface */
.pn-embed, .pn-embed body {
  margin: 0 !important;
  padding: 0 !important;
  height: 100% !important;
  overflow: hidden !important;
  background: transparent !important;
}
.pn-embed body > * { display: none !important; }
.pn-embed body {}
/* Keep the game surface visible */
.pn-embed #game-container, 
.pn-embed #game-container * {
  display: revert !important;
}
.pn-embed #game-container {
  position: fixed !important;
  inset: 0 !important;
  margin: 0 !important;
  width: 100vw !important;
  height: 100vh !important;
  overflow: hidden !important;
}
/* Canvas fills; preserves internal scaling */
.pn-embed canvas {
  display: block !important;
}
/* Mobile controls only on mobile */
@media (min-width: 1001px) {
  .pn-embed .joystick,
  .pn-embed #mobile-controls,
  .pn-embed .mobile-controls,
  .pn-embed [class*="joystick"],
  .pn-embed [id*="joystick"] {
    display: none !important;
    pointer-events: none !important;
  }
}
</style>

</head>
<body>

  <header class="topbar">
    <button class="btn" id="px-exit">✕ EXIT</button>
    <div class="title">
      <span class="muted">PIXEL-NET</span>
      <strong>NEON CHASE</strong>
    </div>
    <button class="badge" id="px-badge" title="Click to change initials">
      <span class="dot"></span>
      <span id="px-initials">???</span>
    </button>
  </header>

  <div class="layout">
    <aside class="panel howto">
      <h2>HOW TO PLAY</h2>
      <ul class="howto-list"><li><strong>Move</strong><br><span class="muted">Arrow Keys / Swipe</span></li><li><strong>Collect Bits</strong><br><span class="muted">+10 each</span></li><li><strong>Power Bit</strong><br><span class="muted">+50 → Hack drones</span></li><li><strong>Advance</strong><br><span class="muted">Clear all bits to advance zones</span></li></ul>
      <div class="hint muted">Initials are set on the homepage. Click the badge (top-right) to change.</div>
    </aside>

    <main class="panel center">
      <div class="center-head">
        <h1>NEON CHASE</h1>
      </div>
      <div class="gamewrap">
        <div class="gamebox" id="px-gamebox">
          <div id="game-container">
          <canvas id="gameCanvas"></canvas>

          <div id="ui-layer">
            <div class="hud-bar">
              <div id="score-display">BITS: <span id="score-val">0</span></div>
              <div id="level-display">ZONE: <span id="level-val">1</span></div>
              <div id="high-score">TOP: <span id="high-score-val">0</span></div>
            </div>
            <div class="hud-bar" style="justify-content: flex-end;">
              <div id="lives-display">UNITS: <span id="lives-val">3</span></div>
            </div>
          </div>

          <div id="overlay"><!-- injected by JS --></div>
        </div>
      
        </div>
      </div>
      <div class="foot muted">Leaderboard refreshes automatically.</div>
    </main>

    <aside class="panel lb">
      <h2>LEADERBOARD</h2>
      <div class="lb-sub muted">Top 10</div>
      <div id="px-lb" class="lb-list">
        <div class="muted">Loading…</div>
      </div>
    </aside>
  </div>

  <script src="../../js/engine.js"></script>
  <script>
    (function() {
      const SLUG = "neon-chase";
      const lbEl = document.getElementById('px-lb');
      const initialsEl = document.getElementById('px-initials');
      const badge = document.getElementById('px-badge');
      const exitBtn = document.getElementById('px-exit');

      function getInitials() {
        const v = localStorage.getItem('px_player_initials') || localStorage.getItem('pixelnet_initials') || '';
        return (v || '???').toString().trim().toUpperCase().slice(0, 3);
      }

      function setInitialsUI() {
        initialsEl.textContent = getInitials();
      }

      badge.addEventListener('click', () => {
        const cur = getInitials();
        const v = prompt('Enter your initials (3 letters):', cur);
        if (!v) return;
        const clean = v.toString().replace(/[^A-Za-z0-9]/g,'').toUpperCase().slice(0,3);
        if (!clean) return;
        localStorage.setItem('px_player_initials', clean);
        localStorage.setItem('pixelnet_initials', clean);
        setInitialsUI();
      });

      exitBtn.addEventListener('click', () => {
        window.location.href = '../../index.html';
      });

      async function renderLeaderboard() {
        try {
          const data = await PixelNet.getLeaderboard(SLUG);
          const rows = (data && (data.scores || data.leaderboard || data)) || [];
          if (!rows.length) {
            lbEl.innerHTML = '<div class="muted">No scores yet.</div>';
            return;
          }
          const top = rows.slice(0, 10);
          lbEl.innerHTML = top.map((r, i) => {
            const name = (r.initials || r.player || r.name || '???').toString().toUpperCase().slice(0,3);
            const score = (r.score ?? r.points ?? 0);
            return `<div class="lb-row"><span class="rk">#${i+1}</span><span class="nm">${name}</span><span class="sc">${score}</span></div>`;
          }).join('');
        } catch (e) {
          lbEl.innerHTML = '<div class="muted">Leaderboard failed to load.</div>';
        }
      }

      setInitialsUI();
      renderLeaderboard();
      setInterval(renderLeaderboard, 5000);

      // Mobile: allow scrolling outside gamebox, but prevent scroll gestures inside game area.
      const gamebox = document.getElementById('px-gamebox');
      gamebox.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive:false });
    })();
  </script>

<script>

/**
 * NEON CHASE (PIXEL-NET INTEGRATION)
 * Your gameplay is preserved; only leaderboard/initials are moved to PIXEL-NET backend.
 */

/* ========= PIXEL-NET SCORE + LB ========= */
const GAME_SLUG = "neon-chase";
let scoreSubmitted = false;

function getInitialsFromStorage() {
  const raw = (
    localStorage.getItem("px_player_initials") ||
    localStorage.getItem("px_initials") ||
    localStorage.getItem("pixelnet_initials") ||
    localStorage.getItem("playerInitials") ||
    sessionStorage.getItem("playerInitials") ||
    localStorage.getItem("initials") ||
    "???"
  );
  return String(raw).toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 3) || "???";
}

async function refreshLeaderboard() {
  const status = document.getElementById("lbStatus");
  const list = document.getElementById("lbList");
  if (!status || !list || !window.PixelNet) return;

  status.textContent = "Loading…";
  list.innerHTML = "";

  try {
    const data = await PixelNet.getLeaderboard(GAME_SLUG);
    const entries = (data && data.entries) ? data.entries : (Array.isArray(data) ? data : []);

    const topScore = entries.length ? (entries[0].score ?? 0) : 0;
    highScore = Number(topScore) || 0;
    document.getElementById("high-score-val").textContent = highScore;

    entries.slice(0, 10).forEach((e, idx) => {
      const li = document.createElement("li");
      const name = (e.name || e.initials || "???").toString().toUpperCase().slice(0, 3);
      const sc = Number(e.score) || 0;
      li.textContent = `${idx + 1}. ${name} — ${sc}`;
      list.appendChild(li);
    });

    status.textContent = entries.length ? "" : "No scores yet.";
  } catch (err) {
    status.textContent = "Leaderboard failed to load.";
    console.log("[NEON-CHASE] leaderboard error:", err);
  }
}

/**
 * AUDIO ENGINE
 * Updated sounds for a "tech" feel
 */
const AudioEngine = (() => {
    let ctx = null;
    let enabled = false;

    const init = () => {
        if (!ctx) {
            ctx = new (window.AudioContext || window.webkitAudioContext)();
            enabled = true;
        } else if (ctx.state === 'suspended') {
            ctx.resume();
        }
    };

    const playTone = (freq, type, duration, vol = 0.1) => {
        if (!enabled || !ctx) return;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        gain.gain.setValueAtTime(vol, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start();
        osc.stop(ctx.currentTime + duration);
    };

    return {
        init,
        step: () => { // "Tick" instead of Waka
            if (!enabled) return;
            playTone(800, 'square', 0.05, 0.02);
        },
        eatDrone: () => playTone(1200, 'sawtooth', 0.1, 0.1),
        crash: () => {
            if (!enabled) return;
            for(let i=0; i<5; i++) {
                setTimeout(() => playTone(100 - (i*20), 'sawtooth', 0.2, 0.2), i*50);
            }
        },
        start: () => {
            if (!enabled) return;
            playTone(440, 'sine', 0.1, 0.1);
            setTimeout(() => playTone(880, 'sine', 0.3, 0.1), 150);
        }
    };
})();

const TILE_SIZE = 24; 
const WALL_COLOR = '#00FF41'; // Matrix Green
const GATE_COLOR = '#FF0055';

// 0: Empty, 1: Wall, 2: Bit, 3: Power Up, 4: Drone Gate
const MAP = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,1,2,1,1,2,1,2,1,1,2,1,1,1,2,1],
    [1,3,1,1,1,2,1,1,2,1,2,1,1,2,1,1,1,3,1],
    [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,1,2,1,2,1,1,1,2,1,2,1,1,1,2,1],
    [1,2,2,2,2,2,1,2,2,1,2,2,1,2,2,2,2,2,1],
    [1,1,1,1,1,2,1,1,0,1,0,1,1,2,1,1,1,1,1],
    [0,0,0,0,1,2,1,0,0,4,0,0,1,2,1,0,0,0,0],
    [1,1,1,1,1,2,1,0,1,1,1,0,1,2,1,1,1,1,1],
    [0,2,2,2,2,2,0,0,1,0,1,0,0,2,2,2,2,2,0],
    [1,1,1,1,1,2,1,0,1,1,1,0,1,2,1,1,1,1,1],
    [0,0,0,0,1,2,1,0,0,0,0,0,1,2,1,0,0,0,0],
    [1,1,1,1,1,2,1,2,1,1,1,2,1,2,1,1,1,1,1],
    [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
    [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
    [1,3,2,1,2,2,2,2,2,0,2,2,2,2,2,1,2,3,1],
    [1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1],
    [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

const COLS = MAP[0].length;
const ROWS = MAP.length;

// Game State
let canvas, ctx;
let gameInterval;
let score = 0;
let level = 1;
let highScore = 0;
let lives = 3;
let gameState = 'START'; 
let powerModeTime = 0;
let flashTimer = 0;

// Entities
let player = {};
let drones = [];
let particles = [];
let bits = [];

// Input
let nextDir = { x: 0, y: 0 }; 
let touchStartX = 0;
let touchStartY = 0;

class Entity {
    constructor(x, y, color) {
        this.x = x * TILE_SIZE + TILE_SIZE/2;
        this.y = y * TILE_SIZE + TILE_SIZE/2;
        this.color = color;
        this.dir = { x: 0, y: 0 };
        this.speed = 2;
        this.radius = TILE_SIZE * 0.4;
    }
    getGridPos() {
        return { c: Math.floor(this.x / TILE_SIZE), r: Math.floor(this.y / TILE_SIZE) };
    }
    isCentered() {
        const threshold = 1.0;
        const centerX = (this.getGridPos().c * TILE_SIZE) + TILE_SIZE/2;
        const centerY = (this.getGridPos().r * TILE_SIZE) + TILE_SIZE/2;
        return Math.abs(this.x - centerX) < threshold && Math.abs(this.y - centerY) < threshold;
    }
    snapToGrid() {
        const p = this.getGridPos();
        this.x = p.c * TILE_SIZE + TILE_SIZE/2;
        this.y = p.r * TILE_SIZE + TILE_SIZE/2;
    }
    canMove(dx, dy) {
        const p = this.getGridPos();
        const nextC = p.c + dx;
        const nextR = p.r + dy;
        if (nextC < 0 || nextC >= COLS) return true;
        if (nextR >= 0 && nextR < ROWS) {
            const tile = MAP[nextR][nextC];
            return tile !== 1 && tile !== 4;
        }
        return false;
    }
    move() {
        if (this.x < 0) this.x = canvas.width;
        if (this.x > canvas.width) this.x = 0;
        this.x += this.dir.x * this.speed;
        this.y += this.dir.y * this.speed;
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, '#00F0FF'); // Cyan
        this.pulse = 0;
    }
    update() {
        if (this.isCentered()) {
            if (nextDir.x !== 0 || nextDir.y !== 0) {
                if (this.canMove(nextDir.x, nextDir.y)) {
                    this.snapToGrid();
                    this.dir = { ...nextDir };
                }
            }
            if (!this.canMove(this.dir.x, this.dir.y)) {
                this.snapToGrid();
                this.dir = { x: 0, y: 0 };
            }
        }
        this.move();

        if ((this.dir.x !== 0 || this.dir.y !== 0) && Math.random() < 0.1) {
             AudioEngine.step();
        }

        const p = this.getGridPos();
        if (p.r >= 0 && p.r < ROWS && p.c >= 0 && p.c < COLS) {
            const bitIndex = bits.findIndex(b => b.c === p.c && b.r === p.r);
            if (bitIndex !== -1) {
                const b = bits[bitIndex];
                bits.splice(bitIndex, 1);
                if (b.type === 2) score += 10;
                else if (b.type === 3) { score += 50; activatePowerMode(); }
                if (bits.length === 0) winGame();
            }
        }
    }
    draw() {
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;

        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius * 0.4, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;
    }
}

class Drone extends Entity {
    constructor(x, y, color, type) {
        super(x, y, color);
        this.originalColor = color;
        this.type = type;
        let baseSpeed = 1.5;
        if (level >= 2) baseSpeed = 2.0;
        if (level >= 5) baseSpeed = 2.4; 
        this.speed = baseSpeed; 
        this.mode = 'SCATTER';
        this.dir = { x: 0, y: 0 };
        this.inHouse = true;
    }
    update() {
        if (this.isCentered()) {
            const options = [];
            const dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
            dirs.forEach(d => {
                if (d.x === -this.dir.x && d.y === -this.dir.y && this.dir.x !==0) return;
                const p = this.getGridPos();
                const nextC = p.c + d.x;
                const nextR = p.r + d.y;
                if (nextC >=0 && nextC < COLS && nextR >=0 && nextR < ROWS) {
                    const tile = MAP[nextR][nextC];
                    if (tile === 1) return;
                    if (tile === 4 && !this.inHouse) return;
                    options.push(d);
                }
            });
            if (options.length > 0) {
                if (this.mode === 'FRIGHTENED') {
                    this.dir = options[Math.floor(Math.random() * options.length)];
                } else {
                    if (this.mode === 'CHASE' && Math.random() > 0.4) {
                        let bestDir = options[0];
                        let minDist = 999999;
                        options.forEach(opt => {
                            const tx = (this.getGridPos().c + opt.x) * TILE_SIZE;
                            const ty = (this.getGridPos().r + opt.y) * TILE_SIZE;
                            const dist = Math.hypot(tx - player.x, ty - player.y);
                            if (dist < minDist) { minDist = dist; bestDir = opt; }
                        });
                        this.dir = bestDir;
                    } else {
                         this.dir = options[Math.floor(Math.random() * options.length)];
                    }
                }
                this.snapToGrid();
            } else {
                this.dir = { x: -this.dir.x, y: -this.dir.y };
            }
        }
        this.move();
        const dist = Math.hypot(this.x - player.x, this.y - player.y);
        if (dist < TILE_SIZE) {
            if (this.mode === 'FRIGHTENED') {
                AudioEngine.eatDrone();
                this.reset();
                score += 200;
                createParticles(this.x, this.y, this.originalColor);
            } else if (this.mode !== 'EATEN') {
                killPlayer();
            }
        }
    }
    reset() {
        this.x = 9 * TILE_SIZE + TILE_SIZE/2;
        this.y = 8 * TILE_SIZE + TILE_SIZE/2;
        this.mode = 'CHASE';
        this.dir = {x:0, y:-1};
        this.inHouse = true;
        let releaseTime = Math.max(500, 2000 - (level * 200));
        setTimeout(() => { this.inHouse = false; }, releaseTime);
    }
    draw() {
        const color = (this.mode === 'FRIGHTENED') ? 
                      ((flashTimer > 0 && Math.floor(Date.now() / 200) % 2 === 0) ? '#fff' : '#00f') : 
                      this.originalColor;
        ctx.fillStyle = color;

        const r = this.radius;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - r);
        ctx.lineTo(this.x + r, this.y + r);
        ctx.lineTo(this.x - r, this.y + r);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(this.x, this.y, r/3, 0, Math.PI*2);
        ctx.fill();
    }
}

function init() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    canvas.width = COLS * TILE_SIZE;
    canvas.height = ROWS * TILE_SIZE;
    const _pi = document.getElementById("playInitials");
    if (_pi) _pi.textContent = getInitialsFromStorage();
    refreshLeaderboard();

    window.addEventListener('keydown', handleKey);
    window.addEventListener('touchstart', handleTouchStart, {passive: false});
    window.addEventListener('touchend', handleTouchEnd, {passive: false});

    showStartScreen();
    resetLevel();
    draw();
}

function showStartScreen() {
    gameState = 'START';
    scoreSubmitted = false;

    const ov = document.getElementById('overlay');
    ov.classList.remove('hidden');

    ov.innerHTML = `
        <h1>NEON CHASE</h1>
        <p>ARROWS / SWIPE to Move<br>Collect Bits & Hack Drones</p>
        <button onclick="startGame()">INITIATE</button>
        <div class="mobile-hint">Tip: Quick swipes. Don’t scroll.</div>
    `;

    refreshLeaderboard();
}

function resetLevel() {
    bits = [];
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (MAP[r][c] === 2) bits.push({c, r, type: 2});
            if (MAP[r][c] === 3) bits.push({c, r, type: 3});
        }
    }
    resetEntities();
}

function resetEntities() {
    player = new Player(9, 15);
    drones = [
        new Drone(9, 8, '#FF0055', 0),
        new Drone(8, 9, '#FF9900', 1),
        new Drone(10, 9, '#CC00FF', 2),
        new Drone(9, 9, '#FFFF00', 3)
    ];
    drones[0].inHouse = false;
    drones[0].dir = {x: -1, y: 0};
    nextDir = { x: 0, y: 0 };
}

function startGame() {
    AudioEngine.init();
    AudioEngine.start();
    document.getElementById('overlay').classList.add('hidden');
    score = 0;
    lives = 3;
    level = 1;
    scoreSubmitted = false;
    updateUI();
    gameState = 'PLAY';
    resetLevel();
    if (gameInterval) clearInterval(gameInterval);
    gameInterval = setInterval(gameLoop, 1000/60);
}

function winGame() {
    gameState = 'LEVEL_TRANSITION';
    AudioEngine.start();
    level++;

    const ov = document.getElementById('overlay');
    ov.classList.remove('hidden');
    ov.innerHTML = `<h1>ZONE ${level}</h1><p>SYNCING...</p>`;

    clearInterval(gameInterval);
    setTimeout(() => {
        ov.classList.add('hidden');
        gameState = 'PLAY';
        resetLevel();
        gameInterval = setInterval(gameLoop, 1000/60);
    }, 3000);
}

function gameOver() {
    gameState = 'GAMEOVER';
    clearInterval(gameInterval);

    const finalScore = Math.floor(score);

    if (!scoreSubmitted && window.PixelNet && Number.isFinite(finalScore)) {
        scoreSubmitted = true;
        PixelNet.submitScore(GAME_SLUG, finalScore);
        setTimeout(refreshLeaderboard, 900);
    }

    const ov = document.getElementById('overlay');
    ov.classList.remove('hidden');
    ov.innerHTML = `
        <h1 style="color:#FF0055">SYSTEM FAILURE</h1>
        <p>BITS: ${finalScore}</p>
        <button onclick="showStartScreen()">REBOOT</button>
    `;
}

function killPlayer() {
    lives--;
    updateUI();
    AudioEngine.crash();
    createParticles(player.x, player.y, '#00F0FF');
    if (lives <= 0) {
        gameOver();
    } else {
        resetEntities();
    }
}

function activatePowerMode() {
    let duration = Math.max(120, 600 - ((level-1) * 60));
    powerModeTime = duration;
    flashTimer = 0;
    drones.forEach(g => { if (g.mode !== 'EATEN') g.mode = 'FRIGHTENED'; });
}

function createParticles(x, y, color) {
    for(let i=0; i<8; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 5,
            vy: (Math.random() - 0.5) * 5,
            life: 30,
            color: color
        });
    }
}

function updateUI() {
    document.getElementById('score-val').textContent = score;
    document.getElementById('high-score-val').textContent = highScore;
    document.getElementById('lives-val').textContent = lives;
    document.getElementById('level-val').textContent = level;
}

function gameLoop() {
    if (gameState !== 'PLAY') return;
    player.update();
    drones.forEach(g => g.update());
    if (powerModeTime > 0) {
        powerModeTime--;
        if (powerModeTime < 120) flashTimer++;
        if (powerModeTime === 0) {
            drones.forEach(g => { if (g.mode === 'FRIGHTENED') g.mode = 'CHASE'; });
        }
    }
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
    }
    updateUI();
    draw();
}

function draw() {
    ctx.fillStyle = '#050010';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            const x = c * TILE_SIZE;
            const y = r * TILE_SIZE;
            if (MAP[r][c] === 1) {
                ctx.strokeStyle = WALL_COLOR;
                ctx.lineWidth = 1;
                ctx.strokeRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                ctx.shadowBlur = 5;
                ctx.shadowColor = WALL_COLOR;
                ctx.strokeRect(x + 4, y + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                ctx.shadowBlur = 0;
            } else if (MAP[r][c] === 4) {
                ctx.strokeStyle = GATE_COLOR;
                ctx.beginPath();
                ctx.moveTo(x, y + TILE_SIZE/2);
                ctx.lineTo(x + TILE_SIZE, y + TILE_SIZE/2);
                ctx.stroke();
            }
        }
    }

    bits.forEach(b => {
        const x = b.c * TILE_SIZE + TILE_SIZE/2;
        const y = b.r * TILE_SIZE + TILE_SIZE/2;
        ctx.fillStyle = '#00F0FF';
        if (b.type === 2) {
            ctx.fillRect(x-1, y-1, 2, 2);
        } else {
            if (Math.floor(Date.now() / 100) % 2 === 0) {
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    });

    player.draw();
    drones.forEach(g => g.draw());
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 3, 3);
    });
}

function handleKey(e) {
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].indexOf(e.code) > -1) {
        e.preventDefault();
    }
    switch(e.code) {
        case 'ArrowUp': nextDir = { x: 0, y: -1 }; break;
        case 'ArrowDown': nextDir = { x: 0, y: 1 }; break;
        case 'ArrowLeft': nextDir = { x: -1, y: 0 }; break;
        case 'ArrowRight': nextDir = { x: 1, y: 0 }; break;
    }
}

function handleTouchStart(e) {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
}

function handleTouchEnd(e) {
    const touchEndX = e.changedTouches[0].clientX;
    const touchEndY = e.changedTouches[0].clientY;
    const dx = touchEndX - touchStartX;
    const dy = touchEndY - touchStartY;
    if (Math.abs(dx) > Math.abs(dy)) {
        if (Math.abs(dx) > 30) nextDir = dx > 0 ? {x:1, y:0} : {x:-1, y:0};
    } else {
        if (Math.abs(dy) > 30) nextDir = dy > 0 ? {x:0, y:1} : {x:0, y:-1};
    }
}

init();

</script>
</body>
</html>
