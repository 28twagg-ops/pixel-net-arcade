<!--
THEME CONFIGURATION FOR AI IMPLEMENTATION:
Theme: Retro Arcade / Neon Cyberpunk
Font: 'Courier New', Courier, monospace
Style: High contrast, CRT scanline effect, glowing vectors
Colors:
  - Player: #0ff (Cyan)
  - Human: #f0f (Magenta)
  - Grunt: #f00 (Red)
  - Hulk: #0f0 (Green)
  - Enforcer: #ff9900 (Orange)
  - Bullets: #ff0 (Yellow) / #ff4400 (Red-Orange)
  - Background: #050505 (Near Black) with #1a1a1a radial gradient
Purpose: AI implementation for themes
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Robo-Arena: Retro Arcade Shooter (version 2.0)</title>
    <style>
        html, body { height:100%; margin:0; overflow:hidden; }

body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; /* Prevent browser zooming/scrolling on touch */
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Add a subtle CRT scanline effect */
            background: radial-gradient(circle, #1a1a1a 0%, #000 100%);
        }

        canvas {
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.15);
            border: 4px solid #222;
            background-color: #000;
            max-width: 100%;
            max-height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            font-size: 20px;
            text-shadow: 0 0 5px currentColor;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .hud-score { color: #0ff; }
        .hud-lives { color: #f0f; }
        .hud-level { color: #ff0; }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 5px;
            color: #f00;
            text-transform: uppercase;
            text-shadow: 4px 4px 0px #fff;
            letter-spacing: 5px;
            text-align: center;
        }

        p {
            font-size: 1rem;
            margin-bottom: 20px;
            color: #ddd;
            text-align: center;
            line-height: 1.4;
            max-width: 600px;
        }

        .btn {
            background: transparent;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 10px 30px;
            font-size: 1.2rem;
            font-family: inherit;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
            box-shadow: 0 0 10px #0f0;
            margin-top: 20px;
        }

        .btn:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 20px #0f0;
        }

        .controls-info {
            display: flex;
            gap: 40px;
            margin-bottom: 20px;
            font-size: 0.8rem;
            color: #aaa;
        }
        
        .key-group {
            text-align: center;
        }
        
        .key {
            display: inline-block;
            border: 1px solid #666;
            padding: 2px 6px;
            border-radius: 4px;
            color: #fff;
            background: #222;
        }

        /* Leaderboard Styles */
        .leaderboard {
            margin-top: 10px;
            border: 2px solid #444;
            padding: 15px;
            background: rgba(20, 20, 20, 0.8);
            width: 300px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
        }
        /* h3 removed from leaderboard styles */
        .score-row { 
            display: flex; 
            justify-content: space-between; 
            margin: 5px 0; 
            font-family: monospace; 
            font-size: 1.1rem; 
        }
        .score-rank { color: #888; margin-right: 10px; }
        .score-name { color: #0ff; }
        .score-val { color: #fff; }

        /* High Score Input */
        #high-score-form {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            animation: pulse 1s infinite alternate;
        }

        @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.02); } }

        #initials-input {
            background: #000; 
            border: 2px solid #0f0; 
            color: #0f0;
            font-family: 'Courier New', monospace; 
            font-size: 2.5rem;
            width: 120px; 
            text-align: center; 
            text-transform: uppercase;
            outline: none;
            padding: 5px;
        }

        /* Mobile Controls */
        #mobile-controls {
            display: none; /* Hidden by default, shown via JS on touch devices */
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 150px;
            pointer-events: none;
            justify-content: space-between;
            padding: 0 40px;
            box-sizing: border-box;
        }

        .joystick-zone {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
            pointer-events: auto;
        }

        .joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .hidden { display: none !important; }

        @media (max-width: 768px) {
            h1 { font-size: 2rem; }
            .controls-info { display: none; }
            #mobile-controls { display: flex; }
            .leaderboard { width: 90%; font-size: 0.9rem; }
        }
    
/* touch-only controls */
.mobile-controls{display:none;}
@media (hover:none) and (pointer:coarse){
  .mobile-controls{display:flex;}
}

</style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="hud-score">SCORE: <span id="scoreDisplay">0</span></div>
            <div class="hud-level">LEVEL: <span id="levelDisplay">1</span></div>
            <div class="hud-lives">LIVES: <span id="livesDisplay">3</span></div>
        </div>
    </div>

    <div id="start-screen">
        <h1>ROBO-ARENA</h1>
        <p>Protect Humans. Destroy Robots.<br>Aliens appear Level 2+.</p>
        
        <div class="controls-info">
            <div class="key-group">
                <div>MOVE</div>
                <div><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span></div>
            </div>
            <div class="key-group">
                <div>SHOOT</div>
                <div><span class="key">↑</span><span class="key">←</span><span class="key">↓</span><span class="key">→</span></div>
            </div>
        </div>

        <!-- Leaderboard removed -->

        <button class="btn" id="startBtn">INSERT COIN</button>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1 style="color: #fff">GAME OVER</h1>
        <p>FINAL SCORE: <span id="finalScore" style="color: #0ff; font-size: 1.5rem">0</span></p>
        
        <div id="high-score-form">
            <p style="color: #ff0; font-weight: bold; margin: 0;">NEW HIGH SCORE!</p>
            
            <button class="btn" id="submitScoreBtn">ENTER INITIALS</button>
        </div>

        <div id="standard-game-over-controls">
            <button class="btn" id="restartBtn">TRY AGAIN</button>
        </div>
    </div>

    <div id="mobile-controls">
        <div class="joystick-zone" id="stick-move">
            <div class="joystick-knob" id="knob-move"></div>
        </div>
        <div class="joystick-zone" id="stick-aim">
            <div class="joystick-knob" id="knob-aim"></div>
        </div>
    </div>
</div>

<script>
/**
 * ROBO-ARENA
 * A retro arcade shooter inspired by Robotron: 2084
 */

// --- High Score System ---
const HighScoreSys = (() => {
    const KEY = 'robo_arena_scores_v2_0_copy';
    const MAX_SCORES = 5;
    
    // Default scores to populate if empty
    const defaults = [
        { name: 'ACE', score: 200 },
        { name: 'KAI', score: 200 },
        { name: 'JAY', score: 200 },
        { name: 'MAX', score: 200 },
        { name: 'LEO', score: 200 }
    ];

    function getScores() {
        try {
            const stored = localStorage.getItem(KEY);
            return stored ? JSON.parse(stored) : defaults;
        } catch(e) {
            return defaults;
        }
    }

    function saveScores(scores) {
        try {
            localStorage.setItem(KEY, JSON.stringify(scores));
        } catch(e) {
            console.error("Storage failed", e);
        }
    }

    function isHighScore(score) {
        const scores = getScores();
        return scores.length < MAX_SCORES || score > scores[scores.length - 1].score;
    }

    function addScore(name, score) {
        const scores = getScores();
        scores.push({ name: name.toUpperCase() || 'UNK', score });
        scores.sort((a, b) => b.score - a.score);
        if (scores.length > MAX_SCORES) {
            scores.splice(MAX_SCORES); // Keep top N
        }
        saveScores(scores);
    }

    return { getScores, isHighScore, addScore };
})();

// --- Audio System ---
const AudioSys = (() => {
    let ctx = null;
    let masterGain = null;

    function init() {
        if (!ctx) {
            ctx = new (window.AudioContext || window.webkitAudioContext)();
            masterGain = ctx.createGain();
            masterGain.gain.value = 0.3; // Keep volume reasonable
            masterGain.connect(ctx.destination);
        }
        if (ctx.state === 'suspended') ctx.resume();
    }

    function playTone(freq, type, duration, vol = 1, slideTo = null) {
        if (!ctx) return;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, ctx.currentTime);
        if (slideTo) {
            osc.frequency.exponentialRampToValueAtTime(slideTo, ctx.currentTime + duration);
        }

        gain.gain.setValueAtTime(vol, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(masterGain);
        osc.start();
        osc.stop(ctx.currentTime + duration);
    }

    function shoot() { playTone(800, 'square', 0.1, 0.5, 300); }
    function enemyShoot() { playTone(400, 'sawtooth', 0.15, 0.5, 200); }
    function explosion() { playTone(100, 'sawtooth', 0.4, 0.8, 10); }
    function pickup() { playTone(1200, 'sine', 0.2, 0.6, 2000); }
    function levelUp() { 
        setTimeout(() => playTone(600, 'square', 0.1, 0.6), 0);
        setTimeout(() => playTone(800, 'square', 0.1, 0.6), 100);
        setTimeout(() => playTone(1200, 'square', 0.4, 0.6), 200);
    }
    function die() { playTone(500, 'sawtooth', 1.0, 1.0, 50); }
    function highScore() {
        playTone(1000, 'square', 0.1, 0.5);
        setTimeout(() => playTone(1500, 'square', 0.1, 0.5), 100);
        setTimeout(() => playTone(2000, 'square', 0.2, 0.5), 200);
    }

    return { init, shoot, enemyShoot, explosion, pickup, levelUp, die, highScore };
})();

// --- Constants & Config ---
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 600;
const TILE_SIZE = 40; // Grid size for spawn logic

const COLORS = {
    PLAYER: '#0ff', // Cyan
    HUMAN: '#f0f',  // Magenta
    GRUNT: '#f00',  // Red
    HULK: '#0f0',   // Green
    ENFORCER: '#ff9900', // Orange Alien
    BULLET: '#ff0', // Yellow
    ENEMY_BULLET: '#ff4400', // Red-Orange
    OBSTACLE: '#333'
};

// --- Game Engine ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
ctx.shadowBlur = 0;

let animationId;
let lastTime = 0;

// Game State
const state = {
    active: false,
    level: 1,
    score: 0,
    lives: 3,
    entities: [],
    particles: [],
    width: 0,
    height: 0,
    waveCompleteTimer: 0
};

// Input State
const input = {
    keys: {},
    move: { x: 0, y: 0 },
    aim: { x: 0, y: 0 },
    firing: false
};

// --- Classes ---

class Entity {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.radius = 10;
        this.dead = false;
        this.vx = 0;
        this.vy = 0;
        this.speed = 0;
        this.color = '#fff';
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // Boundary checks
        if (this.x < this.radius) this.x = this.radius;
        if (this.x > state.width - this.radius) this.x = state.width - this.radius;
        if (this.y < this.radius) this.y = this.radius;
        if (this.y > state.height - this.radius) this.y = state.height - this.radius;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.fillStyle = this.color;
        this.drawShape(ctx);
        ctx.restore();
    }

    drawShape(ctx) {
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fill();
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 'player');
        this.speed = 250;
        this.color = COLORS.PLAYER;
        this.lastShot = 0;
        this.fireRate = 0.08; 
        this.facing = 0; // Angle in radians
        this.animTimer = 0;
    }

    update(dt) {
        this.vx = input.move.x * this.speed;
        this.vy = input.move.y * this.speed;
        
        // Animate legs only when moving
        if (this.vx !== 0 || this.vy !== 0) {
            this.animTimer += dt * 15;
        } else {
            this.animTimer = 0;
        }

        super.update(dt);

        // Update facing direction based on aim or movement
        if (input.aim.x !== 0 || input.aim.y !== 0) {
            this.facing = Math.atan2(input.aim.y, input.aim.x);
            
            // Shooting logic
            this.lastShot -= dt;
            if (this.lastShot <= 0) {
                this.shoot();
                this.lastShot = this.fireRate;
            }
        } else if (input.move.x !== 0 || input.move.y !== 0) {
            // If not shooting, look where walking
            this.facing = Math.atan2(input.move.y, input.move.x);
        }
    }

    shoot() {
        const dx = Math.cos(this.facing);
        const dy = Math.sin(this.facing);
        
        // Spawn bullet slightly in front of the gun arm
        state.entities.push(new Bullet(this.x + dx * 15, this.y + dy * 15, dx, dy, false));
        AudioSys.shoot();
    }

    draw(ctx) {
        // Apply neon glow specific to player
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        super.draw(ctx);
        ctx.shadowBlur = 0; // Reset
    }

    drawShape(ctx) {
        ctx.fillStyle = this.color;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;

        // Legs animation
        const legOffset = Math.sin(this.animTimer) * 6;

        ctx.save();
        // Rotate body to face direction
        ctx.rotate(this.facing);

        // Legs (drawn below body)
        ctx.beginPath();
        ctx.moveTo(-4, 0);
        ctx.lineTo(-8 - legOffset, 0); // Left leg kicks back/forth relative to rotation
        ctx.moveTo(-4, 0);
        ctx.lineTo(-8 + legOffset, 0); // Right leg
        ctx.stroke();

        // Body (Square-ish)
        ctx.fillRect(-6, -6, 12, 12);

        // Head (Circle)
        ctx.beginPath();
        ctx.arc(0, 0, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#fff'; // White visor/helmet
        ctx.fill();

        // Gun Arm (extended)
        ctx.fillStyle = this.color;
        ctx.fillRect(4, -2, 14, 4); // The arm

        ctx.restore();
    }
}

class Bullet extends Entity {
    constructor(x, y, dx, dy, isEnemy = false) {
        super(x, y, isEnemy ? 'enemy_bullet' : 'bullet');
        this.isEnemy = isEnemy;
        this.vx = dx * (isEnemy ? 300 : 800); // Enemy bullets are slower
        this.vy = dy * (isEnemy ? 300 : 800);
        this.radius = 4;
        this.color = isEnemy ? COLORS.ENEMY_BULLET : COLORS.BULLET;
        this.life = 1.5; 
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt;
        if (this.life <= 0) this.dead = true;
        
        // Remove if OOB (optimization)
        if (this.x < 0 || this.x > state.width || this.y < 0 || this.y > state.height) {
            this.dead = true;
        }
    }

    drawShape(ctx) {
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

class Grunt extends Entity {
    constructor(x, y) {
        super(x, y, 'grunt');
        this.speed = 100 + (state.level * 10);
        this.radius = 14;
        this.color = COLORS.GRUNT;
        this.animTimer = 0;
    }

    update(dt) {
        this.animTimer += dt * 5;
        const player = getPlayer();
        if (!player) return;

        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist > 0) {
            this.vx = (dx / dist) * this.speed;
            this.vy = (dy / dist) * this.speed;
        }
        super.update(dt);
    }

    drawShape(ctx) {
        // Retro Robot Shape
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        
        // Body
        ctx.strokeRect(-10, -10, 20, 20);
        
        // Eyes (glowy)
        ctx.fillStyle = '#fff';
        const blink = Math.sin(this.animTimer * 10) > 0.8;
        if (!blink) {
            ctx.fillRect(-6, -4, 4, 4);
            ctx.fillRect(2, -4, 4, 4);
        }

        // Antenna
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(0, -16);
        ctx.stroke();

        // Legs (wobbly)
        const w = Math.sin(this.animTimer * 20) * 4;
        ctx.beginPath();
        ctx.moveTo(-8, 10);
        ctx.lineTo(-8, 16 + w);
        ctx.moveTo(8, 10);
        ctx.lineTo(8, 16 - w);
        ctx.stroke();
        
        ctx.shadowBlur = 0;
    }
}

class Hulk extends Entity {
    constructor(x, y) {
        super(x, y, 'hulk');
        this.speed = 60 + (state.level * 5);
        this.radius = 20; // Bigger
        this.color = COLORS.HULK;
        this.dirChangeTimer = 0;
        this.animTimer = 0;
    }

    update(dt) {
        this.animTimer += dt * 3;
        // Hulks are indestructible to bullets, wander, but seek humans if close
        this.dirChangeTimer -= dt;

        let target = null;
        let minDist = 250; // Increased seek range

        // Find closest human
        state.entities.forEach(e => {
            if (e.type === 'human') {
                const d = Math.hypot(e.x - this.x, e.y - this.y);
                if (d < minDist) {
                    minDist = d;
                    target = e;
                }
            }
        });

        if (target) {
            const dx = target.x - this.x;
            const dy = target.y - this.y;
            this.vx = (dx / minDist) * this.speed;
            this.vy = (dy / minDist) * this.speed;
        } else if (this.dirChangeTimer <= 0) {
            const angle = Math.random() * Math.PI * 2;
            this.vx = Math.cos(angle) * this.speed;
            this.vy = Math.sin(angle) * this.speed;
            this.dirChangeTimer = 1.0;
        }

        super.update(dt);
    }

    drawShape(ctx) {
        // Big heavy robot
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        
        // Main Block
        const pulse = Math.sin(this.animTimer) * 2;
        ctx.fillRect(-16 - pulse, -18, 32 + pulse*2, 30);
        
        // Treadmill feet
        ctx.fillStyle = '#0a0';
        ctx.fillRect(-20, 8, 12, 10);
        ctx.fillRect(8, 8, 12, 10);

        // Face
        ctx.fillStyle = '#000';
        ctx.fillRect(-12, -10, 24, 8);
        
        // Evil Red Eyes
        ctx.fillStyle = '#f00';
        ctx.fillRect(-8, -8, 6, 4);
        ctx.fillRect(2, -8, 6, 4);

        ctx.shadowBlur = 0;
    }
}

class Enforcer extends Entity {
    constructor(x, y) {
        super(x, y, 'enforcer');
        this.speed = 120 + (state.level * 5);
        this.radius = 14;
        this.color = COLORS.ENFORCER;
        this.fireTimer = 2.0 + Math.random(); // Delay first shot
        this.moveTimer = 0;
    }

    update(dt) {
        this.moveTimer += dt;
        const player = getPlayer();
        
        // Movement: Floats eratically
        if (player) {
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            // Orbit/Chase - Wavy movement
            if (dist > 0) {
                this.vx = (dx / dist) * this.speed + Math.sin(this.moveTimer * 3) * 50;
                this.vy = (dy / dist) * this.speed + Math.cos(this.moveTimer * 2) * 50;
            }

            // Shooting
            this.fireTimer -= dt;
            if (this.fireTimer <= 0 && dist < 500) { 
                const angle = Math.atan2(dy, dx);
                // Fire at player
                state.entities.push(new Bullet(this.x, this.y, Math.cos(angle), Math.sin(angle), true));
                this.fireTimer = 2.0 - Math.min(1.5, state.level * 0.1); // Fire faster on high levels
                AudioSys.enemyShoot();
            }
        }

        super.update(dt);
    }

    drawShape(ctx) {
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        
        // Diamond / Saucer shape
        ctx.beginPath();
        ctx.moveTo(0, -12);
        ctx.lineTo(12, 0);
        ctx.lineTo(0, 12);
        ctx.lineTo(-12, 0);
        ctx.closePath();
        ctx.stroke();

        // Inner pulsing core
        const s = 4 + Math.sin(this.moveTimer * 10) * 2;
        ctx.fillStyle = '#fff';
        ctx.fillRect(-s/2, -s/2, s, s);

        ctx.shadowBlur = 0;
    }
}

class Human extends Entity {
    constructor(x, y) {
        super(x, y, 'human');
        this.speed = 40;
        this.radius = 10;
        this.color = COLORS.HUMAN;
        this.changeTimer = 0;
        this.walkAnim = 0;
    }

    update(dt) {
        this.walkAnim += dt * 10;
        // Humans wander aimlessly
        this.changeTimer -= dt;
        if (this.changeTimer <= 0) {
            const angle = Math.random() * Math.PI * 2;
            this.vx = Math.cos(angle) * this.speed;
            this.vy = Math.sin(angle) * this.speed;
            this.changeTimer = 1.0;
        }
        
        if (this.x < 30) this.vx = Math.abs(this.vx);
        if (this.x > state.width - 30) this.vx = -Math.abs(this.vx);
        if (this.y < 30) this.vy = Math.abs(this.vy);
        if (this.y > state.height - 30) this.vy = -Math.abs(this.vy);

        super.update(dt);
    }

    drawShape(ctx) {
        // Stick figure with glow
        ctx.shadowBlur = 8;
        ctx.shadowColor = this.color;
        ctx.strokeStyle = this.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        // Head
        ctx.arc(0, -8, 5, 0, Math.PI*2);
        // Body
        ctx.moveTo(0, -3);
        ctx.lineTo(0, 8);
        // Legs
        const legSwing = Math.sin(this.walkAnim) * 5;
        ctx.lineTo(-6 + legSwing, 16);
        ctx.moveTo(0, 8);
        ctx.lineTo(6 - legSwing, 16);
        // Arms
        ctx.moveTo(0, 0);
        ctx.lineTo(-6 - legSwing/2, 6);
        ctx.moveTo(0, 0);
        ctx.lineTo(6 + legSwing/2, 6);
        ctx.stroke();
        ctx.shadowBlur = 0;
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 150 + 50;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.life = 0.5 + Math.random() * 0.3;
        this.size = Math.random() * 3 + 1;
    }
    
    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt;
    }

    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
        ctx.globalAlpha = 1.0;
    }
}

// --- Utils ---
function getPlayer() {
    return state.entities.find(e => e.type === 'player');
}

function spawnExplosion(x, y, color, count = 10) {
    for(let i=0; i<count; i++) {
        state.particles.push(new Particle(x, y, color));
    }
}

function checkCollision(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    return dist < (a.radius + b.radius);
}

// --- Level Generation ---
function startLevel(levelNum) {
    state.entities = [];
    state.particles = [];
    state.level = levelNum;
    state.waveCompleteTimer = 0; 
    
    // Spawn Player Center
    state.entities.push(new Player(state.width/2, state.height/2));

    // Calculate Spawn Counts (Infinite scaling)
    const gruntCount = 5 + (levelNum * 4); 
    const hulkCount = Math.floor(levelNum * 0.8) + 1;
    // Aliens spawn starting level 2
    const enforcerCount = levelNum >= 2 ? (levelNum - 1) * 2 : 0;
    const humanCount = Math.min(10, 2 + Math.floor(levelNum / 2));

    // Safe Zone for spawning
    const safeDist = 200;
    const cx = state.width/2;
    const cy = state.height/2;

    function getSpawnPos() {
        let x, y, d;
        let attempts = 0;
        do {
            x = Math.random() * (state.width - 60) + 30;
            y = Math.random() * (state.height - 60) + 30;
            d = Math.hypot(x - cx, y - cy);
            attempts++;
            if (attempts > 50) return {x: 50, y: 50}; 
        } while(d < safeDist);
        return {x, y};
    }

    // Spawn Grunts
    for(let i=0; i<gruntCount; i++) {
        const pos = getSpawnPos();
        state.entities.push(new Grunt(pos.x, pos.y));
    }

    // Spawn Hulks
    for(let i=0; i<hulkCount; i++) {
        const pos = getSpawnPos();
        state.entities.push(new Hulk(pos.x, pos.y));
    }

    // Spawn Enforcers
    for(let i=0; i<enforcerCount; i++) {
        const pos = getSpawnPos();
        state.entities.push(new Enforcer(pos.x, pos.y));
    }

    // Spawn Humans
    for(let i=0; i<humanCount; i++) {
        const pos = getSpawnPos();
        state.entities.push(new Human(pos.x, pos.y));
    }
    
    updateHUD();
    AudioSys.levelUp();
}

// --- Main Loop ---
function update(dt) {
    // Input Handling
    // 1. Reset keyboard vectors
    let kMoveX = 0;
    let kMoveY = 0;
    let kAimX = 0;
    let kAimY = 0;

    // 2. Accumulate inputs (opposing keys cancel out)
    if (input.keys['w']) kMoveY -= 1;
    if (input.keys['s']) kMoveY += 1;
    if (input.keys['a']) kMoveX -= 1;
    if (input.keys['d']) kMoveX += 1;

    if (input.keys['arrowup']) kAimY -= 1;
    if (input.keys['arrowdown']) kAimY += 1;
    if (input.keys['arrowleft']) kAimX -= 1;
    if (input.keys['arrowright']) kAimX += 1;

    // 3. Assign to global input state
    input.move.x = kMoveX;
    input.move.y = kMoveY;
    input.aim.x = kAimX;
    input.aim.y = kAimY;

    // 4. Touch Controls Override (if active)
    if (input.touchMove && (input.touchMove.x !== 0 || input.touchMove.y !== 0)) {
        input.move = input.touchMove;
    }
    if (input.touchAim && (input.touchAim.x !== 0 || input.touchAim.y !== 0)) {
        input.aim = input.touchAim;
    }

    // Update Entities
    state.entities.forEach(e => e.update(dt));
    state.particles.forEach(p => p.update(dt));

    // Cleanup Dead/Old
    state.entities = state.entities.filter(e => !e.dead);
    state.particles = state.particles.filter(p => p.life > 0);

    // Collision Detection
    const player = getPlayer();
    const playerBullets = state.entities.filter(e => e.type === 'bullet');
    const enemyBullets = state.entities.filter(e => e.type === 'enemy_bullet');
    const enemies = state.entities.filter(e => ['grunt', 'hulk', 'enforcer'].includes(e.type));
    const humans = state.entities.filter(e => e.type === 'human');

    // Player Bullets vs Enemies
    playerBullets.forEach(b => {
        enemies.forEach(e => {
            if (b.dead || e.dead) return;
            if (checkCollision(b, e)) {
                b.dead = true;
                if (e.type === 'grunt') {
                    e.dead = true;
                    state.score += 100;
                    spawnExplosion(e.x, e.y, COLORS.GRUNT);
                    AudioSys.explosion();
                } else if (e.type === 'enforcer') {
                    e.dead = true;
                    state.score += 500;
                    spawnExplosion(e.x, e.y, COLORS.ENFORCER);
                    AudioSys.explosion();
                } else if (e.type === 'hulk') {
                    // Bullets push Hulks back but don't kill
                    e.x += b.vx * dt * 0.2;
                    e.y += b.vy * dt * 0.2;
                }
            }
        });
    });

    if (player) {
        // Enemies touch Player
        enemies.forEach(e => {
            if (checkCollision(player, e)) {
                killPlayer();
            }
        });

        // Enemy Bullets touch Player
        enemyBullets.forEach(b => {
            if (checkCollision(player, b)) {
                b.dead = true;
                killPlayer();
            }
        });

        // Player vs Humans (Rescue)
        humans.forEach(h => {
            if (checkCollision(player, h)) {
                h.dead = true;
                state.score += 1000;
                spawnExplosion(h.x, h.y, COLORS.HUMAN, 20); // Sparkle
                AudioSys.pickup();
            }
        });
    }

    // Hulk vs Humans
    enemies.filter(e => e.type === 'hulk').forEach(hulk => {
        humans.forEach(human => {
            if (!human.dead && checkCollision(hulk, human)) {
                human.dead = true;
                spawnExplosion(human.x, human.y, '#f00', 30); // Blood/Oil
                AudioSys.die(); // Sad sound
            }
        });
    });

    // Level Complete Check
    const hostileCount = state.entities.filter(e => e.type === 'grunt' || e.type === 'enforcer').length;
    if (hostileCount === 0 && player && !state.waveCompleteTimer) {
        state.waveCompleteTimer = 2.0; // Wait 2 seconds before next level
    }

    if (state.waveCompleteTimer > 0) {
        state.waveCompleteTimer -= dt;
        if (state.waveCompleteTimer <= 0) {
            startLevel(state.level + 1);
        }
    }

    updateHUD();
}

function draw() {
    // Clear Background with trail effect
    ctx.fillStyle = 'rgba(5, 5, 5, 0.4)';
    ctx.fillRect(0, 0, state.width, state.height);

    // Draw Grid (Retro feel) - Enhanced
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 1;
    ctx.beginPath();
    // Offset grid based on time for subtle effect? No, static is more retro.
    for(let x=0; x<=state.width; x+=TILE_SIZE) { ctx.moveTo(x,0); ctx.lineTo(x, state.height); }
    for(let y=0; y<=state.height; y+=TILE_SIZE) { ctx.moveTo(0,y); ctx.lineTo(state.width, y); }
    ctx.stroke();

    // Draw Entities
    // Sort by y to fake depth? Not needed for top-down, but helps overlap.
    state.entities.sort((a,b) => a.y - b.y);
    
    state.entities.forEach(e => e.draw(ctx));
    
    // Particles get glow too
    ctx.shadowBlur = 5;
    state.particles.forEach(p => {
        ctx.shadowColor = p.color;
        p.draw(ctx);
    });
    ctx.shadowBlur = 0;
}

function gameLoop(timestamp) {
    if (!state.active) return;

    if (!lastTime) lastTime = timestamp;
    const dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    update(Math.min(dt, 0.1)); // Cap dt to prevent huge jumps
    draw();

    animationId = requestAnimationFrame(gameLoop);
}

// --- Game Control ---
function killPlayer() {
    const player = getPlayer();
    if (player) {
        spawnExplosion(player.x, player.y, COLORS.PLAYER, 50);
        player.dead = true;
        AudioSys.die();
        state.lives--;
        
        if (state.lives < 0) {
            gameOver();
        } else {
            // Respawn timer
            setTimeout(() => {
                if (state.active) {
                    state.entities.push(new Player(state.width/2, state.height/2));
                    // Nuke nearby enemies to prevent spawn kill
                    state.entities.forEach(e => {
                        if (e.type === 'grunt' || e.type === 'hulk' || e.type === 'enforcer') {
                            const d = Math.hypot(e.x - state.width/2, e.y - state.height/2);
                            if (d < 150) e.dead = true;
                        }
                    });
                }
            }, 1500);
        }
    }
}

function gameOver() {
    state.active = false;
    document.getElementById('game-over-screen').classList.remove('hidden');
    document.getElementById('finalScore').innerText = state.score;

    // No in-game initials prompt. Wrapper owns initials + leaderboard.
    const form = document.getElementById('high-score-form');
    const controls = document.getElementById('standard-game-over-controls');
    if(form) form.style.display = 'none';
    if(controls) controls.style.display = 'block';

    try{
        if(window.parent && window.parent !== window){
            window.parent.postMessage({ type: "GAME_OVER_SCORE", score: state.score }, "*");
        }
    }catch(_){}
}

function resetGame() {
    state.score = 0;
    state.lives = 3;
    state.level = 1;
    state.entities = [];
    state.active = true;
    state.waveCompleteTimer = 0;
    lastTime = 0;
    
    // Clear inputs on reset to prevent drift
    input.keys = {};
    input.move = {x:0, y:0};
    input.aim = {x:0, y:0};
    
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('game-over-screen').classList.add('hidden');
    
    resize();
    AudioSys.init();
    startLevel(1);
    gameLoop(0);
}

function renderLeaderboard() {
    const list = document.getElementById('score-list');
    if (!list) return; // Safety check if element doesn't exist
    list.innerHTML = '';
    const scores = HighScoreSys.getScores();
    scores.forEach((s, idx) => {
        const row = document.createElement('div');
        row.className = 'score-row';
        row.innerHTML = `
            <div><span class="score-rank">#${idx + 1}</span><span class="score-name">${s.name}</span></div>
            <span class="score-val">${s.score}</span>
        `;
        list.appendChild(row);
    });
}

// --- HUD & Helpers ---
function updateHUD() {
    document.getElementById('scoreDisplay').innerText = state.score;
    document.getElementById('levelDisplay').innerText = state.level;
    document.getElementById('livesDisplay').innerText = state.lives >= 0 ? state.lives : 0;
}

function resize() {
    state.width = window.innerWidth;
    state.height = window.innerHeight;
    canvas.width = state.width;
    canvas.height = state.height;
}

// --- Input Event Listeners ---
window.addEventListener('keydown', (e) => {
    // Prevent scrolling with arrows/space
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].indexOf(e.code) > -1) {
        e.preventDefault();
    }
    input.keys[e.key.toLowerCase()] = true;
});

window.addEventListener('keyup', (e) => {
    input.keys[e.key.toLowerCase()] = false;
});

// Safety: Clear keys if window loses focus (prevents sticky keys)
window.addEventListener('blur', () => {
    input.keys = {};
    input.move = {x:0, y:0};
    input.aim = {x:0, y:0};
});

window.addEventListener('resize', resize);

// Joystick Logic
function setupJoystick(elementId, knobId, inputTarget) {
    const zone = document.getElementById(elementId);
    const knob = document.getElementById(knobId);
    
    let touchId = null;
    const maxDist = 35;

    zone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        touchId = touch.identifier;
        updateJoystick(touch.clientX, touch.clientY);
    }, {passive: false});

    zone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        for (let i=0; i<e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === touchId) {
                updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
            }
        }
    }, {passive: false});

    const endTouch = (e) => {
        e.preventDefault();
        for (let i=0; i<e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === touchId) {
                touchId = null;
                knob.style.transform = `translate(-50%, -50%)`;
                input[inputTarget] = {x:0, y:0};
            }
        }
    };

    zone.addEventListener('touchend', endTouch);
    zone.addEventListener('touchcancel', endTouch);

    function updateJoystick(cx, cy) {
        const rect = zone.getBoundingClientRect();
        const centerX = rect.left + rect.width/2;
        const centerY = rect.top + rect.height/2;

        let dx = cx - centerX;
        let dy = cy - centerY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist > maxDist) {
            dx = (dx / dist) * maxDist;
            dy = (dy / dist) * maxDist;
        }

        knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        
        // Normalize output -1 to 1
        input[inputTarget] = {
            x: dx / maxDist,
            y: dy / maxDist
        };
    }
}

// Initialize Joysticks
setupJoystick('stick-move', 'knob-move', 'touchMove');
setupJoystick('stick-aim', 'knob-aim', 'touchAim');

// Buttons & Form
document.getElementById('startBtn').addEventListener('click', () => {
    AudioSys.init();
    resetGame();
});

document.getElementById('restartBtn').addEventListener('click', () => {
    resetGame();
});

try{document.getElementById('submitScoreBtn')?.addEventListener('click', ()=>{});}catch(_){ }
// Force uppercase in input
document.getElementById('initials-input').addEventListener('input', function() {
    this.value = this.value.toUpperCase();
});

// Initial Setup
resize();
renderLeaderboard();

</script>
</body>
</html>